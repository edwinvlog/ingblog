<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>限流算法</title>
      <link href="/posts/62837/"/>
      <url>/posts/62837/</url>
      
        <content type="html"><![CDATA[<p>限流是解决高并发大流量的一种方案，至少是可以保证应用的可用性。</p><p>通常有以下两种限流方案：</p><ul><li>漏桶算法</li><li>令牌桶算法</li></ul><ol><li>漏桶算法</li></ol><p><img src="https://images.gitee.com/uploads/images/2019/1012/140256_281c1966_5028606.png" alt="输入图片说明" title="在这里输入图片标题"></p><p>漏桶算法非常简单，就是将流量放入桶中并按照一定的速率流出。如果流量过大时候并不会提高流出效率，而溢出的流量也只能是抛弃掉了。</p><p>这种算法很简单，但也非常粗暴，无法应对突发的大流量。 这时可以考虑令牌桶算法。</p><ol start="2"><li>漏桶算法</li></ol><p><img src="https://images.gitee.com/uploads/images/2019/1012/140416_24502d26_5028606.gif" alt="输入图片说明" title="在这里输入图片标题"></p><p>令牌桶算法是按照恒定的速率向桶中放入令牌，每当请求经过时则消耗一个或多个令牌。当桶中的令牌为 0 时，请求则会被阻塞。</p><p>令牌桶算法支持先消费后付款，比如一个请求可以获取多个甚至全部的令牌，但是需要后面的请求付费。也就是说后面的请求需要等到桶中的令牌补齐之后才能继续获取。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public BaseResponse&lt;UserResVO&gt; getUserByFeignBatch(@RequestBody UserReqVO userReqVO) &#123;</span><br><span class="line">        //调用远程服务</span><br><span class="line">        OrderNoReqVO vo = new OrderNoReqVO() ;</span><br><span class="line">        vo.setReqNo(userReqVO.getReqNo());</span><br><span class="line"></span><br><span class="line">        RateLimiter limiter = RateLimiter.create(2.0) ;</span><br><span class="line">        //批量调用</span><br><span class="line">        for (int i = 0 ;i&lt; 10 ; i++)&#123;</span><br><span class="line">            double acquire = limiter.acquire();</span><br><span class="line">            logger.debug(&quot;获取令牌成功!,消耗=&quot; + acquire);</span><br><span class="line">            BaseResponse&lt;OrderNoResVO&gt; orderNo = orderServiceClient.getOrderNo(vo);</span><br><span class="line">            logger.debug(&quot;远程返回:&quot;+JSON.toJSONString(orderNo));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        UserRes userRes = new UserRes() ;</span><br><span class="line">        userRes.setUserId(123);</span><br><span class="line">        userRes.setUserName(&quot;张三&quot;);</span><br><span class="line"></span><br><span class="line">        userRes.setReqNo(userReqVO.getReqNo());</span><br><span class="line">        userRes.setCode(StatusEnum.SUCCESS.getCode());</span><br><span class="line">        userRes.setMessage(&quot;成功&quot;);</span><br><span class="line"></span><br><span class="line">        return userRes ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 限流 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 限流 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发军规</title>
      <link href="/posts/23956/"/>
      <url>/posts/23956/</url>
      
        <content type="html"><![CDATA[<ol><li>并发控制，一锁二判三更新，并行查询控超时，乐观悲观要合适</li><li>幂等拦截，幂等字段要对齐，上下游要约定好，异常场景防击穿</li><li>事务控制，悬挂监控要及时，必须防止空回滚，定是最终一致性</li><li>消息使用，一考虑重复投递，二考虑丢失延迟，消息始终是异步</li><li>缓存使用，数据过期要控制，缓存击穿要兜底，存储容量要考虑</li><li>数据库表，查询执行走索引，数据量大要归档，连接要看机器数</li><li>调度任务，调度重叠要避免，捞取数量可配置，熔断处理必须有</li><li>远程调用，接口规约要明确，请求返回辨超时，还要考虑掉不通</li><li>异常处理，日志打印要规范，降低限流需落实，监控核对全覆盖</li><li>开发自测，CR单侧接口测，断言回归边界值，系统质量不降分</li></ol><p><a href="https://github.com/seaswalker/spring-analysis">https://github.com/seaswalker/spring-analysis</a></p>]]></content>
      
      
      <categories>
          
          <category> 规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池使用问题</title>
      <link href="/posts/4726/"/>
      <url>/posts/4726/</url>
      
        <content type="html"><![CDATA[<h3 id="先看个代码："><a href="#先看个代码：" class="headerlink" title="先看个代码："></a>先看个代码：</h3><p> <img src="https://i4you.gitee.io/img/i4you/lALPDgQ9rKDFnI_NAbvNAzE_817_443.png" alt="newFixedThreadPool"></p><h3 id="上面代码产生的问题"><a href="#上面代码产生的问题" class="headerlink" title="上面代码产生的问题"></a>上面代码产生的问题</h3><pre><code>    生产两台服务器爆内存，被搞死了</code></pre><h3 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h3><blockquote><p> 方法内部使用了线程池, 方法被请求一次，就会创建一个线程池，每个线程池都存活着一个线程， 并且被占用的内存不会被GC回收</p></blockquote><blockquote><p>  o &#x3D; future.get(1, TimeUnit.MILLSECONDS) ; 这行代码是为了获取异步线程的返回值，但是超时时间设置的太少 1毫秒，也会造成问题</p></blockquote><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><pre><code>如果局部使用线程池，用完后不再使用它，一定记得手动关闭线程池,否则跑着跑着就内存爆炸崩溃。回收函数如下：</code></pre> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> //执行此函数后线程池不再接收新任务，并等待所有任务执行完毕后销毁线程。此函数并不会等待线程销毁完毕，而是立即返回的</span><br><span class="line">executor.shutdown();</span><br><span class="line">//如想要同步等待线程池完成关闭，可使用下面的函数判断是否都执行完毕了，该函数等待timeout后，返回是否所有任务都执行完毕了</span><br><span class="line">pool.awaitTermination(timeout,TimeUnit)</span><br><span class="line"></span><br><span class="line">//尝试结束所有活动线程，并返回等待队列里的任务</span><br><span class="line">executor.shutdownNow();</span><br></pre></td></tr></table></figure><p>​               </p>]]></content>
      
      
      <categories>
          
          <category> 点滴 </category>
          
          <category> 线程池使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mongo 创建索引语句</title>
      <link href="/posts/22330/"/>
      <url>/posts/22330/</url>
      
        <content type="html"><![CDATA[<h4 id="1-单个索引"><a href="#1-单个索引" class="headerlink" title="1 单个索引"></a>1 单个索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.tf_kd_bus_online_data.createIndex(</span><br><span class="line">&#123;&quot;req_dts&quot;:1&#125; , &#123;background:true&#125;</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-复合索引"><a href="#2-复合索引" class="headerlink" title="2  复合索引"></a>2  复合索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.tf_kd_bus_online_data.createIndex(</span><br><span class="line">&#123; &quot;interface_code&quot;:1, &quot;req_dts&quot;: 1, &quot;resp_dts&quot;: 1, &quot;status&quot;:1&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 点滴 </category>
          
          <category> mongo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongo </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis集群——主从同步</title>
      <link href="/posts/3153/"/>
      <url>/posts/3153/</url>
      
        <content type="html"><![CDATA[<ul><li><p>写在前面</p><pre><code>  很多企业都没有使用到 Redis 的集群，但是至少都做了主从。有了主从，当 master 挂</code></pre><p>  掉的时候，运维让从库过来接管，服务就可以继续，否则 master 需要经过数据恢复和重启<br>  的过程，这就可能会拖很长的时间，影响线上业务的持续服务。<br>  在了解 Redis 的主从复制之前，让我们先来理解一下现代分布式系统的理论基石——<br>  CAP 原理</p></li></ul><h3 id="1-CPA-原理"><a href="#1-CPA-原理" class="headerlink" title="1 CPA 原理"></a>1 CPA 原理</h3><pre><code>    CAP 原理就好比分布式领域的牛顿定律，它是分布式存储的理论基石。自打 CAP 的论文发表之后，分布式存储中间件犹如雨后春笋般一个一个涌现出来。理解这个原理其实很简单，本节我们首先对这个原理进行一些简单的讲解。</code></pre><ul><li><p>C Consistent  一致性</p></li><li><p>A  Availability  可用性</p></li><li><p>P  Partition toleranc   分区容忍性</p><pre><code>  分布式系统的节点往往都是分布在不同的机器上进行网络隔离开的，这意味着必然会有</code></pre><p>  网络断开的风险，这个网络断开的场景的专业词汇叫着「 网络分区」。<br>  在网络分区发生时，两个分布式节点之间无法进行通信，我们对一个节点进行的修改操<br>  作将无法同步到另外一个节点，所以数据的「一致性」将无法满足，因为两个分布式节点的<br>  数据不再保持一致。除非我们牺牲「可用性」，也就是暂停分布式节点服务，在网络分区发<br>  生时，不再提供修改数据的功能，直到网络状况完全恢复正常再继续对外提供服务。</p><p> <img src="https://i4you.gitee.io/img/i4you/redis_001.png" alt="redis主从图"></p><p> 一句话概括 CAP 原理就是——<strong>网络分区发生时，一致性和可用性两难全</strong></p></li></ul><h4 id="1-1-最终一致性"><a href="#1-1-最终一致性" class="headerlink" title="1.1 最终一致性"></a>1.1 最终一致性</h4><pre><code>       Redis 的主从数据是异步同步的，所以分布式的 Redis 系统并不满足「一致性」要求。   当客户端在 Redis 的主节点修改了数据后，立即返回，即使在主从网络断开的情况下，主节   点依旧可以正常对外提供修改服务，所以 Redis 满足「可用性」。   Redis 保证「最终一致性」，从节点会努力追赶主节点，最终从节点的状态会和主节点   的状态将保持一致。如果网络断开了，主从节点的数据将会出现大量不一致，一旦网络恢   复，从节点会采用多种策略努力追赶上落后的数据，继续尽力保持和主节点一致。    </code></pre><h4 id="1-2-主从同步"><a href="#1-2-主从同步" class="headerlink" title="1.2 主从同步"></a>1.2 主从同步</h4><pre><code>      Redis 同步支持主从同步和从从同步，从从同步功能是 Redis 后续版本增加的功能，为  了减轻主库的同步负担。后面为了描述上的方便，统一理解为主从同步。   </code></pre><p><img src="https://i4you.gitee.io/img/i4you/redis_002.png" alt="redis主从图"> </p><h4 id="1-3-增量同步"><a href="#1-3-增量同步" class="headerlink" title="1.3 增量同步"></a>1.3 增量同步</h4><pre><code>        Redis 同步的是指令流，主节点会将那些对自己的状态产生修改性影响的指令记录在本   地的内存 buffer 中，然后异步将 buffer 中的指令同步到从节点，从节点一边执行同步的指   令流来达到和主节点一样的状态，一遍向主节点反馈自己同步到哪里了 (偏移量)。   因为内存的 buffer 是有限的，所以 Redis 主库不能将所有的指令都记录在内存 buffer    中。Redis 的复制内存 buffer 是一个定长的环形数组，如果数组内容满了，就会从头开始覆   盖前面的内容。    </code></pre><p><img src="https://i4you.gitee.io/img/i4you/redis_003.png" alt="redis增量同步"> </p><pre><code>        如果因为网络状况不好，从节点在短时间内无法和主节点进行同步，那么当网络状况恢    复时，Redis 的主节点中那些没有同步的指令在 buffer 中有可能已经被后续的指令覆盖掉    了，从节点将无法直接通过指令流来进行同步，这个时候就需要用到更加复杂的同步机制 —    — 快照同步。</code></pre><h4 id="1-4-快照同步"><a href="#1-4-快照同步" class="headerlink" title="1.4 快照同步"></a>1.4 快照同步</h4><pre><code>           快照同步是一个非常耗费资源的操作，它首先需要在主库上进行一次 bgsave 将当前内      存的数据全部快照到磁盘文件中，然后再将快照文件的内容全部传送到从节点。从节点将快      照文件接受完毕后，立即执行一次全量加载，加载之前先要将当前内存的数据清空。加载完      毕后通知主节点继续进行增量同步。          在整个快照同步进行的过程中，主节点的复制 buffer 还在不停的往前移动，如果快照同      步的时间过长或者复制 buffer 太小，都会导致同步期间的增量指令在复制 buffer 中被覆      盖，这样就会导致快照同步完成后无法进行增量复制，然后会再次发起快照同步，如此极有      可能会陷入快照同步的死循环。         </code></pre><p><img src="https://i4you.gitee.io/img/i4you/redis_004.png" alt="redis快照同步"> </p><pre><code>     所以务必配置一个合适的复制 buffer 大小参数，避免快照复制的死循环。</code></pre><h4 id="1-5-增加从节点"><a href="#1-5-增加从节点" class="headerlink" title="1.5 增加从节点"></a>1.5 增加从节点</h4><pre><code>      当从节点刚刚加入到集群时，它必须先要进行一次快照同步，同步完成后再继续进行增  量同步。   </code></pre><h4 id="1-6-无盘复制"><a href="#1-6-无盘复制" class="headerlink" title="1.6 无盘复制"></a>1.6 无盘复制</h4><pre><code>         主节点在进行快照同步时，会进行很重的文件 IO 操作，特别是对于非 SSD 磁盘存储    时，快照会对系统的负载产生较大影响。特别是当系统正在进行 AOF 的 fsync 操作时如果    发生快照，fsync 将会被推迟执行，这就会严重影响主节点的服务效率。         所以从 Redis 2.8.18 版开始支持无盘复制。所谓无盘复制是指主服务器直接通过套接字    将快照内容发送到从节点，生成快照是一个遍历的过程，主节点会一边遍历内存，一遍将序    列化的内容发送到从节点，从节点还是跟之前一样，先将接收到的内容存储到磁盘文件中，    再进行一次性加载。     </code></pre><h4 id="1-7-Wait-指令"><a href="#1-7-Wait-指令" class="headerlink" title="1.7 Wait 指令"></a>1.7 Wait 指令</h4><pre><code>        Redis 的复制是异步进行的，wait 指令可以让异步复制变身同步复制，确保系统的强一    致性 (不严格)。wait 指令是 Redis3.0 版本以后才出现的。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; set key value</span><br><span class="line"> OK</span><br><span class="line">&gt; wait 1 0</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>        wait 提供两个参数，第一个参数是从库的数量 N，第二个参数是时间 t，以毫秒为单   位。它表示等待 wait 指令之前的所有写操作同步到 N 个从库 (也就是确保 N 个从库的同   步没有滞后)，最多等待时间 t。如果时间 t=0，表示无限等待直到 N 个从库同步完成达成   一致。        假设此时出现了网络分区，wait 指令第二个参数时间 t=0，主从同步无法继续进行，   wait 指令会永远阻塞，Redis 服务器将丧失可用性。    </code></pre><h4 id="1-8-小结"><a href="#1-8-小结" class="headerlink" title="1.8 小结"></a>1.8 小结</h4><pre><code>        主从复制是 Redis 分布式的基础，Redis 的高可用离开了主从复制将无从进行。后面的    章节我们会开始讲解 Redis 的集群模式，这几种集群模式都依赖于本节所讲的主从复制。    不过复制功能也不是必须的，如果你将 Redis 只用来做缓存，跟 memcache 一样来对    待，也就无需要从库做备份，挂掉了重新启动一下就行。但是只要你使用了 Redis 的持久化    功能，就必须认真对待主从复制，它是系统数据安全的基础保障。            </code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 集群 </category>
          
          <category> 主从 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 集群 </tag>
            
            <tag> 主从 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Radix Tree、B+树、跳表之间的区别</title>
      <link href="/posts/31197/"/>
      <url>/posts/31197/</url>
      
        <content type="html"><![CDATA[<h3 id="B-树和跳跃表有什么关联？"><a href="#B-树和跳跃表有什么关联？" class="headerlink" title="B+树和跳跃表有什么关联？"></a>B+树和跳跃表有什么关联？</h3><ol><li>B+树和跳跃表这两种数据结构在本身设计上是有亲缘关系的，其实如果把B+树拉直来看不难发现其结构和跳跃表很相似，甚至B+树的父亲结点其实类似跳跃表的level层级。</li><li>在当前计算机硬件存储设计上，B+树能比跳表存储更大量级的数据，因为跳表需要通过增加层高来提高索引效率，而B+树只需要增加树的深度。此外B+树同一叶子的连续性更加符合当代计算机的存储结构。然而跳表的层高具有随机性，当层高较大的时候磁盘插入会带来一定的开销，且不利于分块。</li></ol><h3 id="为什么Redis不使用B-树呢而选择跳表呢？"><a href="#为什么Redis不使用B-树呢而选择跳表呢？" class="headerlink" title="为什么Redis不使用B+树呢而选择跳表呢？"></a>为什么Redis不使用B+树呢而选择跳表呢？</h3><ul><li>因为数据有序性的实现B+树不如跳表，跳表的时间性能是优于B+树的（B+树不是二叉树，二分的效率是比较高的）。此外跳表最低层就是一条链表，对于需要实现范围查询的功能是比较有利的，而且Redis是基于内存设计的，无需考虑海量数据的场景。</li></ul><h3 id="Radix-Tree优势在哪？"><a href="#Radix-Tree优势在哪？" class="headerlink" title="Radix Tree优势在哪？"></a>Radix Tree优势在哪？</h3><ul><li>本质上是前缀树，所以存储有「公共前缀」的数据时，比 B+ 树、跳表节省内存</li><li>没有公共前缀的数据项，压缩存储，value 用 listpack 存储，也可以节省内存</li><li>查询复杂度是 O(K)，只与「目标长度」有关，与总数据量无关</li><li>这种数据结构也经常用在搜索引擎提示、文字自动补全等场景</li></ul><h3 id="Radix-Tree劣势在哪？"><a href="#Radix-Tree劣势在哪？" class="headerlink" title="Radix Tree劣势在哪？"></a>Radix Tree劣势在哪？</h3><ul><li>如果数据集公共前缀较少，会导致内存占用多</li><li>增删节点需要处理其它节点的「分裂、合并」，跳表只需调整前后指针即可</li><li>B+ 树、跳表范围查询友好，直接遍历链表即可，Radix Tree 需遍历树结构</li><li>实现难度高比 B+ 树、跳表复杂</li><li>不适合存储像UUID等，非对称结构的key（而且使用时候建议让Redis自动生成）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> B+树 </tag>
            
            <tag> RadixTree </tag>
            
            <tag> 跳表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Synchronized原理分析(一)</title>
      <link href="/posts/51789/"/>
      <url>/posts/51789/</url>
      
        <content type="html"><![CDATA[<p>synchronized 对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 <strong>monitorenter 和 monitorexit</strong>。</p><p><strong>synchronized 关键字底层原理属于 JVM 层面。</strong></p><h2 id="1、synchronized同步语句块"><a href="#1、synchronized同步语句块" class="headerlink" title="1、synchronized同步语句块"></a>1、synchronized同步语句块</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedClass</span>()&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;MY SYNCHRONIZED METHOD...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 JDK 自带的 javap 命令查看 SynchronizedClass 类的相关<strong>字节码</strong>信息：首先切换到类的对应目录执行 <strong>javac</strong> SynchronizedClass.java 命令生成<strong>编译后的 .class 文件</strong>，然后执行 <strong>javap -c -s -v -l SynchronizedClass.class</strong> 反编译。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">javase</span>.thread.SynchronizedClass &#123;</span><br><span class="line">  <span class="keyword">public</span> javase.thread.SynchronizedClass();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: dup</span><br><span class="line">       <span class="number">2</span>: astore_1</span><br><span class="line">       <span class="number">3</span>: monitorenter</span><br><span class="line">       <span class="number">4</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">7</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String synchronized 代码块</span></span><br><span class="line">       <span class="number">9</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">12</span>: aload_1</span><br><span class="line">      <span class="number">13</span>: monitorexit</span><br><span class="line">      <span class="number">14</span>: <span class="keyword">goto</span>          <span class="number">22</span></span><br><span class="line">      <span class="number">17</span>: astore_2</span><br><span class="line">      <span class="number">18</span>: aload_1</span><br><span class="line">      <span class="number">19</span>: monitorexit</span><br><span class="line">      <span class="number">20</span>: aload_2</span><br><span class="line">      <span class="number">21</span>: athrow</span><br><span class="line">      <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">4</span>    <span class="number">14</span>    <span class="number">17</span>   any</span><br><span class="line">          <span class="number">17</span>    <span class="number">20</span>    <span class="number">17</span>   any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面反编译结果可以看出：</p><p><strong>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong> 当执行 monitorenter 指令时，线程试图<strong>获取锁</strong>也就是获取 <strong>monitor</strong>(monitor 对象存在于每个 Java 对象的<strong>对象头</strong>中，synchronized 锁便是通过这种方式获取锁的，也是为什么 <strong>Java 中任意对象可以作为锁</strong>的原因) 的持有权。当计数器为 0 则可以<strong>成功获取</strong>，获取后将<strong>锁计数器</strong>设为 1 也就是加 1。相应的在执行 <strong>monitorexit</strong> 指令后，将<strong>锁计数器设为 0</strong>，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。如果有可重入的情况，锁计数器会持续<strong>增加</strong>。</p><h2 id="2、synchronized-修饰方法"><a href="#2、synchronized-修饰方法" class="headerlink" title="2、synchronized 修饰方法"></a>2、synchronized 修饰方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;synchronized 方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> javase.thread.SynchronizedDemo2();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Ljavase/thread/SynchronizedDemo2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (<span class="number">0x0029</span>) ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String synchronized 方法</span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 <strong>ACC_SYNCHRONIZED</strong> 标识，该标识指明了该方法是一个<strong>同步方法</strong>（注意：要出现这个标识，javap 指令必须加 -v 参数，不然显示不完全），JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><p>总结：Java 虚拟机中的 synchronized 是基于进入和退出 monitor 对象实现的，同步分为<strong>显式同步和隐式同步</strong>，同步<strong>代码块</strong>代表着<strong>显式同步</strong>，指的是有明确的 monitorenter 和 monitorexit 指令。<strong>同步方法</strong>代表着<strong>隐式同步</strong>，同步方法是由<strong>方法调用指令</strong>读取运行时常量池中方法的 <strong>ACC_SYNCHRONIZED</strong> 标志来隐式实现的。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Synchronized 多线程 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Synchronized原理分析(二)</title>
      <link href="/posts/2793/"/>
      <url>/posts/2793/</url>
      
        <content type="html"><![CDATA[<h3 id="1、Synchronized同步锁"><a href="#1、Synchronized同步锁" class="headerlink" title="1、Synchronized同步锁"></a>1、Synchronized同步锁</h3><p>   <strong>synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于可重入锁。</strong></p><h4 id="1-1、synchronized作用范围"><a href="#1-1、synchronized作用范围" class="headerlink" title="1.1、synchronized作用范围"></a>1.1、synchronized作用范围</h4><p>  1）作用于方法时，锁住的是对象的实例(this)。</p><p>  2）当作用于静态方法时，锁住的是 Class 实例，又因为 Class 的相关数据存储在永久带 PermGen(jdk1.8 则是 metaspace)，永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程;</p><p>  3）synchronized 作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。</p><h4 id="1-2、synchronized核心组件（6个）"><a href="#1-2、synchronized核心组件（6个）" class="headerlink" title="1.2、synchronized核心组件（6个）"></a>1.2、synchronized核心组件（6个）</h4><p>  1）Wait Set:哪些调用 wait 方法被阻塞的线程被放置在这里；</p><p>  2）Contention List:竞争队列，所有请求锁的线程首先被放在这个竞争队列中;</p><p>  3）Entry List:Contention List 中那些有资格成为候选资源的线程被移动到 Entry List 中;</p><p>  4）OnDeck:任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为 OnDeck;</p><p>  5）Owner:当前已经获取到所资源的线程被称为 Owner;</p><p>  6）!Owner:当前释放锁的线程</p><h4 id="1-4、synchronzied实现"><a href="#1-4、synchronzied实现" class="headerlink" title="1.4、synchronzied实现"></a>1.4、synchronzied实现</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz9nns0eiyj319p0u0n1j.jpg"></p><p>1、JVM 每次从队列的尾部取出一个数据用于锁竞争候选者(OnDeck)，但是并发情况下，ContentionList 会被大量的并发线程进行 CAS 访问，为了降低对尾部元素的竞争，JVM 会将一部分线程移动到 EntryList 中作为候选竞争线程。</p><p>2、Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 EntryList 中，并指定EntryList 中的某个线程为 OnDeck 线程(一般是最先进去的那个线程)。</p><p>3、Owner 线程并不直接把锁传递给 OnDeck 线程，而是把锁竞争的权利交给 OnDeck，OnDeck 需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在JVM 中，也把这种选择行为称之为“竞争切换”。</p><p>4、OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 EntryList中。如果 Owner 线程被 wait 方法阻塞，则转移到WaitSet 队列中，直到某个时刻通过 notify或者 notifyAll 唤醒，会重新进去 EntryList 中。</p><p>5、处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统来完成的(Linux 内核下采用 pthread_mutex_lock 内核函数实现的)。</p><p>6、Synchronized 是非公平锁。 Synchronized 在线程进入 ContentionList 时，等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁资源。</p><p>参考:<a href="https://blog.csdn.net/zqz_zqz/article/details/70233767">https://blog.csdn.net/zqz_zqz/article/details/70233767</a></p><p>7、每个对象都有个 monitor 对象，加锁就是在竞争 monitor 对象，代码块加锁是在前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位ACC_SYNCHRONIZED来判断的</p><p>8、synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。</p><p>9、Java1.6，synchronized 进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中，均对该关键字的实现机理做了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。</p><p>10、锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀;</p><p>11、JDK 1.6 中默认是开启偏向锁和轻量级锁，可以通过-XX:-UseBiasedLocking 来禁用偏向锁。</p><p>[摘自： <a href="https://www.cnblogs.com/bmilk/p/13208961.html]">https://www.cnblogs.com/bmilk/p/13208961.html]</a></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz9owu076pj316v0k1ad2.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 多线程 锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Synchronized 多线程 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B树与B+树的区别</title>
      <link href="/posts/28565/"/>
      <url>/posts/28565/</url>
      
        <content type="html"><![CDATA[<h3 id="1、什么是B树"><a href="#1、什么是B树" class="headerlink" title="1、什么是B树"></a>1、什么是B树</h3><p>​    如果用二叉树作为索引的实现结构，会让树变得很高，增加硬盘的I&#x2F;O次数，影响数据查询的时间。因此一个节点就不能只有2个子节点，而应该允许有M个子节点(M&gt;2)。</p><p>B树的出现就是为了解决这个问题，B树的英文是Balance Tree，也就是平衡的多路搜索树，它的高度远小于平衡二叉树的高度。在文件系统和数据库系统中的索引结构经常采用B树来实现。</p><p><strong>B树的结构</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gzavlzbtkmj30wo0eedh9.jpg"></p><blockquote><p>B树作为平衡的多路搜索树，它的每一个节点最多可以包括M个子节点，M称为B树的阶。同时你能看到，每个磁盘块中包括了关键字和子节点的指针。如果一个磁盘块中包括了x个关键字，那么指针数就是x+1。对于一个100阶的B树来说，如果有3层的话最多可以存储约100万的索引数据。对于大量的索引数据来说，采用B树的结构是非常适合的，因为树的高度要远小于二叉树的高度。</p></blockquote><p><strong>一个M阶的B树（M&gt;2）有以下的特性：</strong></p><ol><li>根节点的儿子数的范围是[2,M]。</li><li>每个中间节点包含k-1个关键字和k个孩子，孩子的数量&#x3D;关键字的数量+1，k的取值范围为[ceil(M&#x2F;2), M]。</li><li>叶子节点包括k-1个关键字（叶子节点没有孩子），k的取值范围为[ceil(M&#x2F;2), M]。</li><li>假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即Key[i]</li><li>所有叶子节点位于同一层。</li></ol><h3 id="2、什么是B-树"><a href="#2、什么是B-树" class="headerlink" title="2、什么是B+树"></a>2、什么是B+树</h3><p>B+树基于B树做出了改进，主流的DBMS都支持B+树的索引方式，比如MySQL。B+树和B树的差异在于以下几点：</p><ol><li>有 k 个孩子的节点就有k个关键字。也就是孩子数量&#x3D;关键字数，而B树中，孩子数量&#x3D;关键字数+1。</li><li>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。</li><li>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而B树中，非叶子节点既保存索引，也保存数据记录。</li><li>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。</li></ol><p><strong>B+树结构图</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gzavm5ai9sj30ru0iq40e.jpg"></p><p>首先，B+树查询效率更稳定。因为B+树每次只有访问到叶子节点才能找到对应的数据，而在B树中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到了非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关键字。</p><p>其次，B+树的查询效率更高，这是因为通常B+树比B树更矮胖（阶数更大，深度更低），查询所需要的磁盘I&#x2F;O也会更少。同样的磁盘页大小，B+树可以存储更多的节点关键字。</p><p>不仅是对单个关键字的查询上，在查询范围上，B+树的效率也比B树高。这是因为所有关键字都出现在B+树的叶子节点中，并通过有序链表进行了链接。而在B树中则需要通过中序遍历才能完成查询范围的查找，效率要低很多</p><h3 id="扩展总结"><a href="#扩展总结" class="headerlink" title="扩展总结"></a>扩展总结</h3><p>一、数据库索引，为什么不适用用二叉树：</p><ol><li>平衡二叉树必须满足（所有节点的左右子树高度差不超过1）。执行插入还是删除操作，只要不满足上述条件，就要通过旋转来保持平衡，而旋转是非常耗时的，所以AVL树适合用于查找多的情况。</li><li>二叉树的数据结构，会导致“深度”，比较深，这种“瘦高”的特性，加大了平均查询的磁盘IO次数，随着数据量的增多，查询效率也会受到影响；</li></ol><p>二、B+ 树和 B 树在构造和查询性能上有什么差异呢？</p><p><strong>B+ 树的中间节点并不直接存储数据。</strong></p><ol><li><strong>B+树的查询效率更加稳定：</strong>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li><li><strong>B+树的磁盘读写代价更低：</strong>B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。</li><li><strong>B+树更加适合在区间查询：</strong>由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> B树 </category>
          
          <category> B+树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> B树 </tag>
            
            <tag> B+树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见设计模式(一)</title>
      <link href="/posts/43229/"/>
      <url>/posts/43229/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gytmkml3wwj30u00w4jtj.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NoClassDefFoundError和ClassNotFoundException</title>
      <link href="/posts/19486/"/>
      <url>/posts/19486/</url>
      
        <content type="html"><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>在写Java程序的时候，当一个类找不到的时候，JVM有时候会抛出 <strong>ClassNotFoundException</strong> 异常，而有时候又会抛出 <strong>NoClassDefFoundError</strong>。看两个异常的字面意思，好像都是类找不到，但是JVM为什么要用两个异常去区分类找不到的情况呢？这个两个异常有什么不同的地方呢？</p><h2 id="2、ClassNotFoundException"><a href="#2、ClassNotFoundException" class="headerlink" title="2、ClassNotFoundException"></a>2、ClassNotFoundException</h2><p><strong>ClassNotFoundException</strong> 是一个运行时异常。从类继承层次上来看，<strong>ClassNotFoundException</strong> 是从 <strong>Exception</strong> 继承的，所以 <strong>ClassNotFoundException</strong> 是一个检查异常。</p><p>当应用程序运行的过程中尝试使用类加载器去加载Class文件的时候，如果没有在 <strong>classpath</strong> 中查找到指定的类，就会抛出 <strong>ClassNotFoundException</strong> 。一般情况下，当我们使用<code>Class.forName()</code>或<code>ClassLoader.loadClass()</code>或<code>ClassLoader.findSystemClass()</code>在运行时加载类的时候，如果类没有被找到，那么就会导致JVM抛出 <strong>ClassNotFoundException</strong>。</p><p>最简单的，当我们使用JDBC去连接数据库的时候，我们一般会使用<code>Class.forName()</code>的方式去加载JDBC的驱动，如果我们没有将驱动放到应用的 <strong>classpath</strong> 下，那么会导致运行时找不到类，所以运行<code>Class.forName()</code>会抛出 <strong>ClassNotFoundException</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ java MainClass</span><br><span class="line">java.lang.ClassNotFoundException: oracle.jdbc.driver.OracleDriver</span><br><span class="line">    at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="number">381</span>)</span><br><span class="line">    at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">424</span>)</span><br><span class="line">    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:<span class="number">331</span>)</span><br><span class="line">    at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">357</span>)</span><br><span class="line">    at java.lang.Class.forName0(Native Method)</span><br><span class="line">    at java.lang.Class.forName(Class.java:<span class="number">264</span>)</span><br><span class="line">    at MainClass.main(MainClass.java:<span class="number">7</span>)</span><br></pre></td></tr></table></figure><h2 id="2、NoClassDefFoundError"><a href="#2、NoClassDefFoundError" class="headerlink" title="2、NoClassDefFoundError"></a>2、NoClassDefFoundError</h2><p><strong>NoClassDefFoundError</strong> 异常，看命名后缀是一个 <strong>Error</strong> 。从类继承层次上看，<strong>NoClassDefFoundError</strong> 是从 <strong>Error</strong> 继承的。和 <strong>ClassNotFoundException</strong> 相比，明显的一个区别是，<strong>NoClassDefFoundError</strong> 并不需要应用程序去关心捕获的问题。</p><p>当JVM在加载一个类的时候，如果这个类在编译时是可用的，但是在运行时找不到这个类的定义的时候，JVM就会抛出一个 <strong>NoClassDefFoundError</strong> 错误。比如当我们在 <strong>new</strong> 一个类的实例的时候，如果在运行是类找不到，则会抛出一个 <strong>NoClassDefFoundError</strong> 的错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class TempClass &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MainClass &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TempClass t = new TempClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ java MainClass</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: TempClass</span><br><span class="line">    at MainClass.main(MainClass.java:6)</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: TempClass</span><br><span class="line">    at java.net.URLClassLoader.findClass(URLClassLoader.java:381)</span><br><span class="line">    at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)</span><br><span class="line">    at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">    ... 1 more</span><br></pre></td></tr></table></figure><h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><table><thead><tr><th align="left">ClassNotFoundException</th><th align="left">NoClassDefFoundError</th></tr></thead><tbody><tr><td align="left">从java.lang.Exception继承，是Exception类型</td><td align="left">从java.lang.Error继承，是Error类型</td></tr><tr><td align="left">当动态加载Class的时候找不到类会抛出ClassNotFoundException异常</td><td align="left">当编译成功以后执行过程中Class找不到导致抛出NoClassDefFoundError错误</td></tr><tr><td align="left">一般在执行Class.forName()、ClassLoader.loadClass()或ClassLoader.findSystemClass()的时候抛出</td><td align="left">由JVM的运行时抛出</td></tr></tbody></table><p>转载：<a href="https://tech101.cn/2018/06/23/ClassNotFoundException_vs_NoClassDefFoundError">https://tech101.cn/2018/06/23/ClassNotFoundException_vs_NoClassDefFoundError</a></p>]]></content>
      
      
      <categories>
          
          <category> java异常 </category>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> java异常 </tag>
            
            <tag> ClassNotFoundException </tag>
            
            <tag> NoClassDefFoundError </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exception和Error</title>
      <link href="/posts/53751/"/>
      <url>/posts/53751/</url>
      
        <content type="html"><![CDATA[<h2 id="1、比Exception和Error，另外，运行时异常与一般异常有什么区别？"><a href="#1、比Exception和Error，另外，运行时异常与一般异常有什么区别？" class="headerlink" title="1、比Exception和Error，另外，运行时异常与一般异常有什么区别？"></a>1、比Exception和Error，另外，运行时异常与一般异常有什么区别？</h2><p>Exception和Error都是继承了Throwable类，在Java中只有Throwable类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。</p><p>Exception和Error体现了Java平台设计者对不同异常情况的分类。Exception是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。</p><p>Error是指在正常情况下，不大可能出现的情况，绝大部分的Error都会导致程序（比如JVM自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如OutOfMemoryError之类，都是Error的子类。</p><p>Exception又分为<strong>可检查</strong>（checked）异常和<strong>不检查</strong>（unchecked）异常，可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。前面我介绍的不可查的Error，是Throwable不是Exception。</p><p>不检查异常就是所谓的运行时异常，类似 NullPointerException、ArrayIndexOutOfBoundsException之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。</p><h3 id="1-1、常见的一些Exception和Error"><a href="#1-1、常见的一些Exception和Error" class="headerlink" title="1.1、常见的一些Exception和Error"></a>1.1、常见的一些Exception和Error</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyj2nw37osj315a0u043e.jpg"></p><p><strong>NoClassDefFoundError和ClassNotFoundException</strong></p>]]></content>
      
      
      <categories>
          
          <category> java异常 </category>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> java异常 </tag>
            
            <tag> Exception </tag>
            
            <tag> Error </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM配置参数</title>
      <link href="/posts/16463/"/>
      <url>/posts/16463/</url>
      
        <content type="html"><![CDATA[<p><strong>机器配置：8核16G</strong></p><h3 id="1、启动参数"><a href="#1、启动参数" class="headerlink" title="1、启动参数"></a>1、启动参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">VM Arguments: jvm_args: </span><br><span class="line">-Dfile.encoding=UTF-<span class="number">8</span> </span><br><span class="line">-Dsun.jnu.encoding=UTF-<span class="number">8</span> </span><br><span class="line">-Djava.io.tmpdir=/tmp </span><br><span class="line">-Djava.net.preferIPv6Addresses=<span class="literal">false</span> </span><br><span class="line">-Xss512k -Xmx12g -Xms12g </span><br><span class="line">-XX:MetaspaceSize=512m </span><br><span class="line">-XX:MaxMetaspaceSize=512m </span><br><span class="line">-XX:+AlwaysPreTouch </span><br><span class="line">-XX:ReservedCodeCacheSize=240m </span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError </span><br><span class="line">-XX:+UseG1GC </span><br><span class="line">-XX:G1HeapRegionSize=4M </span><br><span class="line">-XX:InitiatingHeapOccupancyPercent=<span class="number">40</span> </span><br><span class="line">-XX:MaxGCPauseMillis=<span class="number">100</span> </span><br><span class="line">-XX:+TieredCompilation </span><br><span class="line">-XX:CICompilerCount=<span class="number">4</span> </span><br><span class="line">-XX:-UseBiasedLocking </span><br><span class="line">-XX:+PrintGCDetails </span><br><span class="line">-XX:+PrintGCDateStamps </span><br><span class="line">-XX:+PrintGCTimeStamps </span><br><span class="line">-XX:+PrintAdaptiveSizePolicy </span><br><span class="line">-XX:+PrintGCApplicationStoppedTime </span><br><span class="line">-XX:+PrintHeapAtGC </span><br><span class="line">-XX:+PrintStringTableStatistics </span><br><span class="line">-XX:+PrintTenuringDistribution </span><br><span class="line">-Xloggc:/opt/logs/项目名称gc.log </span><br><span class="line">-XX:+UseGCLogFileRotation </span><br><span class="line">-XX:NumberOfGCLogFiles=<span class="number">30</span> </span><br><span class="line">-XX:GCLogFileSize=50M </span><br><span class="line">-XX:+PrintFlagsFinal </span><br><span class="line">-XX:ErrorFile=/opt/logs/项目名称/vmerr.log </span><br><span class="line">-XX:HeapDumpPath=/opt/logs/项目名称/HeapDump </span><br><span class="line"></span><br><span class="line">java_command: ./项目.jar <span class="title function_">java_class_path</span> <span class="params">(initial)</span>: ./项目.jar Launcher Type: SUN_STANDARD</span><br></pre></td></tr></table></figure><h3 id="2、运行时参数"><a href="#2、运行时参数" class="headerlink" title="2、运行时参数"></a>2、运行时参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">-XX:+AlwaysPreTouch </span><br><span class="line">-XX:CICompilerCount=<span class="number">4</span> </span><br><span class="line">-XX:ConcGCThreads=<span class="number">2</span> </span><br><span class="line">-XX:ErrorFile=/opt/logs/项目名称/vmerr.log </span><br><span class="line">-XX:G1HeapRegionSize=<span class="number">4194304</span> </span><br><span class="line">-XX:GCLogFileSize=<span class="number">52428800</span> </span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError </span><br><span class="line">-XX:HeapDumpPath=/opt/logs/项目名称/HeapDump </span><br><span class="line">-XX:InitialHeapSize=<span class="number">12884901888</span> </span><br><span class="line">-XX:InitiatingHeapOccupancyPercent=<span class="number">40</span> </span><br><span class="line">-XX:MarkStackSize=<span class="number">4194304</span> </span><br><span class="line">-XX:MaxGCPauseMillis=<span class="number">100</span> </span><br><span class="line">-XX:MaxHeapSize=<span class="number">12884901888</span> </span><br><span class="line">-XX:MaxMetaspaceSize=<span class="number">536870912</span> </span><br><span class="line">-XX:MaxNewSize=<span class="number">7730102272</span> </span><br><span class="line">-XX:MetaspaceSize=<span class="number">536870912</span> </span><br><span class="line">-XX:MinHeapDeltaBytes=<span class="number">4194304</span> </span><br><span class="line">-XX:NumberOfGCLogFiles=<span class="number">30</span> </span><br><span class="line">-XX:+PrintAdaptiveSizePolicy </span><br><span class="line">-XX:+PrintFlagsFinal </span><br><span class="line">-XX:+PrintGC </span><br><span class="line">-XX:+PrintGCApplicationStoppedTime </span><br><span class="line">-XX:+PrintGCDateStamps </span><br><span class="line">-XX:+PrintGCDetails </span><br><span class="line">-XX:+PrintGCTimeStamps </span><br><span class="line">-XX:+PrintHeapAtGC </span><br><span class="line">-XX:+PrintStringTableStatistics </span><br><span class="line">-XX:+PrintTenuringDistribution </span><br><span class="line">-XX:ReservedCodeCacheSize=<span class="number">251658240</span> </span><br><span class="line">-XX:ThreadStackSize=<span class="number">512</span> </span><br><span class="line">-XX:+TieredCompilation </span><br><span class="line">-XX:-UseBiasedLocking </span><br><span class="line">-XX:+UseCompressedClassPointers </span><br><span class="line">-XX:+UseCompressedOops </span><br><span class="line">-XX:+UseFastUnorderedTimeStamps </span><br><span class="line">-XX:+UseG1GC </span><br><span class="line">-XX:+UseGCLogFileRotation</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVM配置参数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM配置参数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据结构-Hash</title>
      <link href="/posts/28527/"/>
      <url>/posts/28527/</url>
      
        <content type="html"><![CDATA[<h3 id="1、Redis的hash结构简介"><a href="#1、Redis的hash结构简介" class="headerlink" title="1、Redis的hash结构简介"></a>1、Redis的hash结构简介</h3><p>Redis使用**一个全局Hash表来保存所有的键值对具体值的指针(*key, *value 不是数据本身)**，从而既满足应用存取Hash结构数据需求，又能提供快速查询功能。</p><p>一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，我们常说，一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxnphlqdgfj31je0rc77g.jpg"></p><h3 id="2、hash冲突"><a href="#2、hash冲突" class="headerlink" title="2、hash冲突"></a>2、hash冲突</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxnpiy0hpfj30w80s676p.jpg"></p><p>Redis会对哈希表做rehash操作。rehash也就是增加现有的哈希桶数量，让逐渐增多的entry元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。那具体怎么做呢？</p><p>其实，为了使rehash操作更高效，Redis默认使用了两个全局哈希表：哈希表1和哈希表2。一开始，当你刚插入数据时，默认使用哈希表1，此时的哈希表2并没有被分配空间。随着数据逐步增多，Redis开始执行rehash，这个过程分为三步：</p><ol><li>给哈希表2分配更大的空间，例如是当前哈希表1大小的两倍；</li><li>把哈希表1中的数据重新映射并拷贝到哈希表2中；</li><li>释放哈希表1的空间。</li></ol><p>这个过程看似简单，但是第二步涉及大量的数据拷贝，如果一次性把哈希表1中的数据都迁移完，会造成Redis线程阻塞，无法服务其他请求。此时，Redis就无法快速访问数据了。</p><h3 id="3、渐进式rehash"><a href="#3、渐进式rehash" class="headerlink" title="3、渐进式rehash"></a>3、渐进式rehash</h3><h4 id="3-1背景-why"><a href="#3-1背景-why" class="headerlink" title="3.1背景(why)"></a>3.1背景(why)</h4><p>Hash表在执行rehash时，由于Hash表空间扩大，原本映射到某一位置的键可能会被映射到一个新的位置上，因此，很多键就需要从原来的位置拷贝到新的位置。而在键拷贝时，由于Redis主线程无法执行其他请求，所以键拷贝会阻塞主线程，这样就会产生<strong>rehash开销</strong></p><h4 id="3-2描述-what"><a href="#3-2描述-what" class="headerlink" title="3.2描述(what)"></a>3.2描述(what)</h4><p>上述第二步拷贝数据时，Redis仍然正常处理客户端请求，每处理一个请求时，从哈希表1中的第一个索引位置开始，顺带着将这个索引位置上的所有entries拷贝到哈希表2中；等处理下一个请求时，再顺带拷贝哈希表1中的下一个索引位置的entries</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxnppmfhxgj31ee0u0aen.jpg"></p><p>具体到代码，它的过程是这样的：</p><ol><li>在字典中维持一个索引计数器变量 rehashidx，并将设置为 0，表示 rehash 开始。</li><li>在 rehash 期间，客户端每次对字典进行 CRUD 操作时，会将 ht [0] 中 rehashidx 索引上的值 rehash 到 ht [1]，操作完成后 rehashidx+1。</li><li>字典操作不断执行，最终在某个时间点，所有的键值对完成 rehash，这时将 rehashidx 设置为 - 1，表示 rehash 完成</li></ol><h4 id="3-3-渐进式rehash触发条件-when"><a href="#3-3-渐进式rehash触发条件-when" class="headerlink" title="3.3 渐进式rehash触发条件(when)"></a>3.3 渐进式rehash触发条件(when)</h4><ul><li>服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于或等于1。</li><li>服务端目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于或等于5。</li><li>当哈希表的负载因子小于0.1时，redis会自动开始对哈希表进行缩容操作。</li></ul><p>其中哈希表的负载因子可以通过公式：</p><p># 负载因子 &#x3D; 哈希表以保存节点数量&#x2F;哈希表大小 load_factor &#x3D; ht[0].used &#x2F; ht[0].size</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> reids </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> redis </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reactor模型</title>
      <link href="/posts/28012/"/>
      <url>/posts/28012/</url>
      
        <content type="html"><![CDATA[<h4 id="单线程Reactor模式"><a href="#单线程Reactor模式" class="headerlink" title="单线程Reactor模式"></a>单线程Reactor模式</h4><p>一个线程：<br>单线程：建立连接（Acceptor）、监听accept、read、write事件（Reactor）、处理事件（Handler）都只用一个单线程。</p><h4 id="多线程Reactor模式"><a href="#多线程Reactor模式" class="headerlink" title="多线程Reactor模式"></a>多线程Reactor模式</h4><p>一个线程 + 一个线程池：<br>单线程：建立连接（Acceptor）和 监听accept、read、write事件（Reactor），复用一个线程。<br>工作线程池：处理事件（Handler），由一个工作线程池来执行业务逻辑，包括数据就绪后，用户态的数据读写。</p><h4 id="主从Reactor模式"><a href="#主从Reactor模式" class="headerlink" title="主从Reactor模式"></a>主从Reactor模式</h4><p>三个线程池：<br>主线程池：建立连接（Acceptor），并且将accept事件注册到从线程池。<br>从线程池：监听accept、read、write事件（Reactor），包括等待数据就绪时，内核态的数据I读写。<br>工作线程池：处理事件（Handler），由一个工作线程池来执行业务逻辑，包括数据就绪后，用户态的数据读写</p><p>具体的可以参考并发大神 doug lea 关于Reactor的文章。 <a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf</a><br>再提一点，使用了多路复用，不一定是使用了Reacto模型，Mysql使用了select（为什么不使用epoll，因为Mysql的瓶颈不是网络，是磁盘IO），但是并不是Reactor模型</p><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>nginx：nginx是多进程模型，master进程不处理网络IO，每个Wroker进程是一个独立的单Reacotr单线程模型。<br>netty：通信绝对的王者，默认是多Reactor，主Reacotr只负责建立连接，然后把建立好的连接给到从Reactor，从Reactor负责IO读写。当然可以专门调整为单Reactor。<br>kafka：kafka也是多Reactor，但是因为Kafka主要与磁盘IO交互，因此真正的读写数据不是从Reactor处理的，而是有一个worker线程池，专门处理磁盘IO，从Reactor负责网络IO，然后把任务交给worker线程池处理。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 高性能IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reactor </tag>
            
            <tag> 高性能IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RadixTree优劣</title>
      <link href="/posts/5043/"/>
      <url>/posts/5043/</url>
      
        <content type="html"><![CDATA[<h2 id="RadixTree优势"><a href="#RadixTree优势" class="headerlink" title="RadixTree优势"></a>RadixTree优势</h2><ul><li>本质上是前缀树，所以存储有「公共前缀」的数据时，比 B+ 树、跳表节省内存</li><li>没有公共前缀的数据项，压缩存储，value 用 listpack 存储，也可以节省内存</li><li>查询复杂度是 O(K)，只与「目标长度」有关，与总数据量无关</li><li>这种数据结构也经常用在搜索引擎提示、文字自动补全等场景</li></ul><h2 id="RadixTree不足"><a href="#RadixTree不足" class="headerlink" title="RadixTree不足"></a>RadixTree不足</h2><ul><li>如果数据集公共前缀较少，会导致内存占用多</li><li>增删节点需要处理其它节点的「分裂、合并」，跳表只需调整前后指针即可</li><li>B+ 树、跳表范围查询友好，直接遍历链表即可，Radix Tree 需遍历树结构</li><li>实现难度高比 B+ 树、跳表复杂</li></ul><hr><p>Redis中 Stream 在存消息时，推荐使用默认自动生成的「时间戳+序号」作为消息 ID，不建议自己指定消息 ID，这样才能发挥 Radix Tree 公共前缀的优势。</p><p>每种数据结构都是在面对不同问题场景下，才被设计出来的，结合各自场景中的数据特点，使用优势最大的数据结构才是正解。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> RadixTree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> RadixTree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java对象创建XMind</title>
      <link href="/posts/24306/"/>
      <url>/posts/24306/</url>
      
        <content type="html"><![CDATA[<h1 id="Java对象的创建"><a href="#Java对象的创建" class="headerlink" title="Java对象的创建"></a>Java对象的创建</h1><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz2qeql9pyj31az0u00xk.jpg"></p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h2 id="对象内存分配"><a href="#对象内存分配" class="headerlink" title="对象内存分配"></a>对象内存分配</h2><h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><ul><li><p>空闲列表</p><ul><li><p>不规整空间</p><ul><li>CMS</li></ul></li></ul></li><li><p>指针碰撞</p><ul><li><p>连续规整空间</p><ul><li><p>Serial ParNew</p><ul><li><p>简单高效</p><ul><li>带压缩算法的GC收集器使用</li></ul></li></ul></li></ul></li></ul></li><li><p>CMS分配方式</p><ul><li>Linear Allocation Buffer 空闲列表拿到一大块分配缓冲区之后，在它里面仍然可以使用指 针碰撞方式来分配</li></ul></li></ul><h3 id="并发安全问题"><a href="#并发安全问题" class="headerlink" title="并发安全问题"></a>并发安全问题</h3><ul><li><p>分配动作通过CAS + 失败重试</p></li><li><p>预分配 本地线程分配缓冲(TLAB)， 不够在使用CAS</p><ul><li>-XX:+&#x2F;-UseTLAB</li></ul></li></ul><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><ul><li><p>存储对象自身的运行时数据</p><ul><li>哈希吗</li><li>GC分代年龄</li><li>锁状态</li><li>线程持有的锁</li><li>偏向线程ID</li><li>偏向时间戳</li></ul></li><li><p>类型指针(对象指向它的类型元数据的指针)–不是必须的</p><ul><li>作用：确定对象是那个类的实例</li></ul></li></ul><h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><ul><li><p>各种类型的字段内容(包含从父类中继承的)</p><ul><li><p>存储顺序会 受到虚拟机分配策略参数(-XX:FieldsAllocationStyle参数)和字段在Java源码中定义顺序的影响</p><ul><li><p>HotSpot虚拟机默认的分配顺序为longs&#x2F;doubles、ints、shorts&#x2F;chars、bytes&#x2F;booleans、oops(Ordinary Object Pointers，OOPs)</p><ul><li>相同宽度的字段总是被分配到一起存 放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果HotSpot虚拟机的 +XX:CompactFields参数值为true(默认就为true)，那子类之中较窄的变量也允许插入父类变量的空 隙之中，以节省出一点点空间</li></ul></li></ul></li></ul></li></ul><h3 id="对齐填充-非必须"><a href="#对齐填充-非必须" class="headerlink" title="对齐填充(非必须)"></a>对齐填充(非必须)</h3><ul><li><p>作用：占位符</p><ul><li>原由：HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是 任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数(1倍或者 2倍)，因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全</li></ul></li></ul><h2 id="对象的访问-使用方式"><a href="#对象的访问-使用方式" class="headerlink" title="对象的访问(使用方式)"></a>对象的访问(使用方式)</h2><h3 id="通过reference数据操作堆上的对象"><a href="#通过reference数据操作堆上的对象" class="headerlink" title="通过reference数据操作堆上的对象"></a>通过reference数据操作堆上的对象</h3><ul><li><p>句柄</p><ul><li><p>在堆上划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址</p><ul><li>句柄中包含对象实例数据与类型数据的具体地址</li></ul></li></ul></li><li><p>直接指针</p><ul><li>reference中存储的直接是对象的地址</li></ul></li><li><p>优劣</p><ul><li><p>句柄</p><ul><li>reference中存储的是稳定句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而 reference本身不需要被修改</li></ul></li><li><p>直接指针</p><ul><li>速度更快，它节省了一次指针定位的时间开销</li><li>对象移动后，reference需要更新</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> java对象创建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java对象创建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Collection集合</title>
      <link href="/posts/6832/"/>
      <url>/posts/6832/</url>
      
        <content type="html"><![CDATA[<h2 id="1、Java-为什么要有集合？"><a href="#1、Java-为什么要有集合？" class="headerlink" title="1、Java 为什么要有集合？"></a>1、Java 为什么要有集合？</h2><p>首先，java 是一门面向对象语言，操作对象是我们的日常。既然操作就需要有东西把对象存储起来。于是容器就应运而生，初学者接触到的第一个容器就是数组，但这远远不够，根据不同的对象以及不同的业务，我们需要用到不同的容器。比如，不想要重复对象，我们就会想到用 set 容器，想要对象有序我们会用 List 。不管是 List、Set。他们都会有共性， 而 java 就根据这些共性，给我们提供了 Collection 集合。</p><h2 id="2、Collection接口框架图"><a href="#2、Collection接口框架图" class="headerlink" title="2、Collection接口框架图"></a>2、Collection接口框架图</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxov7dsbymj31im0u0di3.jpg"></p><p>由上面的 Collection 接口框架图，我们可以知道 Collection 是 List、Set、Queue 的父接口，看到这里，你们可能会问，Map 哪去了？其实，Java 中的容器，包括 Collection 和 Map ，Map 是另外一个体系。</p><h2 id="3、Collection的方法"><a href="#3、Collection的方法" class="headerlink" title="3、Collection的方法"></a>3、Collection的方法</h2><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxov906kmlj30mg0tmmzy.jpg" style="zoom:40%;" /><p>Collection 接口定义了以上待实现的方法。比如：</p><ol><li><p>size() 计算容器长度</p></li><li><p>isEmpty() 是否为空</p></li><li><p>contains() 是否包含某个对象</p></li><li><p>containsAll() 是否包含另一个集合的所有对象</p></li><li><p>iterator() 上层接口 iterable 的方法，用于生成迭代对象，遍历对象</p></li><li><p>add() 添加一个对象</p></li><li><p>add() 添加另一个集合的所有对象</p></li><li><p>remove() 移除一个对象</p></li><li><p>removeAll() 移除所有对象</p></li><li><p>toArray() 把集合转换成数组</p></li><li><p>retainAll() 是否与另一个集合有交集</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> collection </category>
          
      </categories>
      
      
        <tags>
            
            <tag> collection </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda表达式(三)</title>
      <link href="/posts/54405/"/>
      <url>/posts/54405/</url>
      
        <content type="html"><![CDATA[<h2 id="1、如何使用-lambda表达式"><a href="#1、如何使用-lambda表达式" class="headerlink" title="1、如何使用 lambda表达式"></a>1、如何使用 lambda表达式</h2><h3 id="1-1-构造器引用"><a href="#1-1-构造器引用" class="headerlink" title="1.1  构造器引用"></a>1.1  构造器引用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructMethodExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 构造方法方法引用--无参数(可以使用方法引用)</span></span><br><span class="line">        Supplier&lt;Method&gt; supplier = Method::<span class="keyword">new</span>;</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">        <span class="comment">// 等价于</span></span><br><span class="line">        Supplier&lt;Method&gt; supplier2 = () -&gt; <span class="keyword">new</span> <span class="title class_">Method</span>();</span><br><span class="line">        System.out.println(supplier2.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法方法引用--有参数</span></span><br><span class="line">        Function&lt;String, Method&gt; uf = name -&gt; <span class="keyword">new</span> <span class="title class_">Method</span>(name);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> uf.apply(<span class="string">&quot;一个优秀的废人&quot;</span>);</span><br><span class="line">        System.out.println(method.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、变量作用域"><a href="#2、变量作用域" class="headerlink" title="2、变量作用域"></a>2、变量作用域</h3><p> lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableScopeTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Converter</span>&lt;T1, T2&gt; &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">convert</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义为 final 强制不能修改</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        Converter&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param + num));</span><br><span class="line">        <span class="comment">// 输出结果为 3</span></span><br><span class="line">        s.convert(<span class="number">2</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> lambda </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda表达式(二)</title>
      <link href="/posts/17447/"/>
      <url>/posts/17447/</url>
      
        <content type="html"><![CDATA[<h2 id="1、如何使用-lambda表达式"><a href="#1、如何使用-lambda表达式" class="headerlink" title="1、如何使用 lambda表达式"></a>1、如何使用 lambda表达式</h2><h3 id="1-1-lambda语法"><a href="#1-1-lambda语法" class="headerlink" title="1.1  lambda语法"></a>1.1  lambda语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式遵循: (接口参数)-&gt;表达式(具体实现的方法)</span></span><br><span class="line">(paramters) -&gt; expression 或 (parameters) -&gt;&#123; expressions; &#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxnzlzb3paj313g0gy771.jpg"></p><p>具体解释，如上图。此外，lambda 语法注意点：</p><ul><li>可选类型声明：方法参数不需要声明参数类型，编译器可以统一识别参数值。</li><li>可选的参数圆括号：一个参数无需定义圆括号，但无参数或多个参数需要定义圆括号。</li><li>可选的大括号：如果具体实现方法只有一个语句，就不需要使用中括号{}。</li><li>可选的返回关键字：如果具体实现方法只有一个表达式，则编译器会自动返回值，如果有多个表达式则，中括号需要指定明表达式返回了一个数值。</li></ul><p>具体使用示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义函数式接口，只能有一个抽象接口，否则会报错</span></span><br><span class="line">    <span class="comment">// 希望在编译期检出报错，请加 @FunctionalInterface 注解</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">        String <span class="title function_">hi</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Hello2</span> &#123;</span><br><span class="line">        String <span class="title function_">hei</span><span class="params">(String hello)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Hello3</span> &#123;</span><br><span class="line">        String <span class="title function_">greet</span><span class="params">(String hello, String name)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 入参为空</span></span><br><span class="line">        <span class="type">Hello</span> <span class="variable">no_param</span> <span class="operator">=</span> () -&gt; <span class="string">&quot;hi, no param&quot;</span>;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">no_param2</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hi, no param&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">      </span><br><span class="line">        System.out.println(no_param.hi());</span><br><span class="line">        System.out.println(no_param2.hi());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单个参数,一条返回语句,可以省略大括号和 return</span></span><br><span class="line">        <span class="type">Hello2</span> <span class="variable">param</span> <span class="operator">=</span> name -&gt; name;</span><br><span class="line">        <span class="type">Hello2</span> <span class="variable">param2</span> <span class="operator">=</span> name -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印</span></span><br><span class="line">        System.out.println(param.hei(<span class="string">&quot;hei, 一个优秀的废人&quot;</span>));</span><br><span class="line">        System.out.println(param2.hei(<span class="string">&quot;hei, 一个优秀的废人&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多个参数</span></span><br><span class="line">        <span class="type">Hello3</span> <span class="variable">multiple</span> <span class="operator">=</span> (String hello, String name) -&gt; hello + <span class="string">&quot; &quot;</span> + name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一条返回语句，可以省略大括号和 return</span></span><br><span class="line">        <span class="type">Hello3</span> <span class="variable">multiple2</span> <span class="operator">=</span> (hello, name) -&gt; hello + name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多条处理语句，需要大括号和 return</span></span><br><span class="line">        <span class="type">Hello3</span> <span class="variable">multiple3</span> <span class="operator">=</span> (hello, name) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; 进入内部 &quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> hello + name;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印</span></span><br><span class="line">        System.out.println(multiple.greet(<span class="string">&quot;hello,&quot;</span>, <span class="string">&quot;祝2019暴富&quot;</span>));</span><br><span class="line">        System.out.println(multiple2.greet(<span class="string">&quot;hello,&quot;</span>, <span class="string">&quot;祝2019暴富&quot;</span>));</span><br><span class="line">        System.out.println(multiple3.greet(<span class="string">&quot;hello,&quot;</span>, <span class="string">&quot;祝2019暴富&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、-方法引用"><a href="#2、-方法引用" class="headerlink" title="2、 方法引用"></a>2、 方法引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; sc = System.out::println;</span><br><span class="line">sc.accept(<span class="string">&quot;一个优秀的废人&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">Consumer&lt;String&gt; sc2 = (x) -&gt; System.out.println(x);</span><br><span class="line">sc2.accept(<span class="string">&quot;一个优秀的废人&quot;</span>);</span><br></pre></td></tr></table></figure><p>Consumer 函数式接口源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析一波：Consumer 是一个函数式接口，抽象方法是 void accept(T t)，参数都是 T。那我们现在有这样一个需求，我想利用这个接口的抽象方法，做一下控制台打印。正常情况下，我们需要实现这个接口，实现它的抽象方法，来实现这个需求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerImpl</span> <span class="keyword">implements</span> <span class="title class_">Consumer</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现之后，这个抽象方法变具体了。作用就是控制台打印，那就意味着抽象方法刚好可以用实际方法： System.out.println(s) 来实现，所以我们可以使用方法引用。</strong></p><p>总结：<strong>函数式接口的抽象方法实现恰好可以通过调用一个实际方法来实现时，就可以用方法引用。</strong></p><p>方法引用的三种形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将抽象方法参数当做实际方法的参数使用</span></span><br><span class="line">对象：：实例方法 objectName::instanceMethod</span><br><span class="line"><span class="comment">// 将抽象方法参数当做实际方法的参数使用</span></span><br><span class="line">类：：静态方法 ClassName::staticMethod</span><br><span class="line"><span class="comment">// 将方法参数的第一个参数当做方法的调用者，其他的参数作为方法的参数</span></span><br><span class="line">类：：实例方法  ClassName::instanceMethod </span><br></pre></td></tr></table></figure><p>自定义一个方法类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Method</span> &#123;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">StaticMethod</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">InstanceMethod</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Method</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参数构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Method</span><span class="params">(String methodName)</span> &#123;</span><br><span class="line">        System.out.println(methodName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态方法引用--通过类名调用</span></span><br><span class="line">        Consumer&lt;String&gt; consumerStatic = Method::StaticMethod;</span><br><span class="line">        consumerStatic.accept(<span class="string">&quot;静态方法&quot;</span>);</span><br><span class="line">        <span class="comment">// 等价于</span></span><br><span class="line">        Consumer&lt;String&gt; consumerStatic2 = (x) -&gt; Method.StaticMethod(x);</span><br><span class="line">        consumerStatic2.accept(<span class="string">&quot;静态方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//非静态方法引用--通过实例调用</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Method</span>();</span><br><span class="line">        Consumer&lt;String&gt; consumerInstance = method::InstanceMethod;</span><br><span class="line">        consumerInstance.accept(<span class="string">&quot;对象的实例方法&quot;</span>);</span><br><span class="line">        <span class="comment">// 等价于</span></span><br><span class="line">        Consumer&lt;String&gt; consumerInstance2 = (x) -&gt; method.InstanceMethod(x);</span><br><span class="line">        consumerInstance2.accept(<span class="string">&quot;对象的实例方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//ClassName::instanceMethod  类的实例方法：把表达式的第一个参数当成 instanceMethod 的调用者，其他参数作为该方法的参数</span></span><br><span class="line">        BiPredicate&lt;String, String&gt; sbp = String::equals;</span><br><span class="line">        System.out.println(<span class="string">&quot;类的实例方法 &quot;</span> + sbp.test(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;A&quot;</span>));</span><br><span class="line">        <span class="comment">// 等效</span></span><br><span class="line">        BiPredicate&lt;String, String&gt; sbp2 = (x, y) -&gt; x.equals(y);</span><br><span class="line">        System.out.println(<span class="string">&quot;类的实例方法 &quot;</span> + sbp2.test(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;A&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">静态方法</span><br><span class="line">静态方法</span><br><span class="line">--------------------------</span><br><span class="line">对象的实例方法</span><br><span class="line">对象的实例方法</span><br><span class="line">--------------------------</span><br><span class="line">类的实例方法<span class="literal">false</span></span><br><span class="line">类的实例方法<span class="literal">false</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> lambda </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据结构-SDS</title>
      <link href="/posts/57494/"/>
      <url>/posts/57494/</url>
      
        <content type="html"><![CDATA[<h3 id="1、Redis设计SDS的背景"><a href="#1、Redis设计SDS的背景" class="headerlink" title="1、Redis设计SDS的背景"></a>1、Redis设计SDS的背景</h3><blockquote><p> 优化C语言char* 字符数组的不足</p><ul><li><p>操作效率低：获取长度需遍历，O(N)复杂度</p></li><li><p>二进制不安全：无法存储包含 \0 的数据（char* 数组用’\0’ 表述字符串结束 ）</p></li></ul></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxnp63whaxj30k407q0sv.jpg"></p><h3 id="2、SDS数据结构"><a href="#2、SDS数据结构" class="headerlink" title="2、SDS数据结构"></a>2、SDS数据结构</h3><p>SDS 结构中记录了字符数组 使用的长度和分配的空间大小，避免了对字符串的遍历操作，可以直接获取到字符串的长度len,降低了操作开销 （<strong>空间换时间</strong>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/* 字符数组现有长度（uint8_t 是8位无符号整形，占用1字节）*/</span> </span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* 字符数组的已分配空间，不包括结构体和0结束字符*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* SDS类型*/</span></span><br><span class="line">    <span class="type">char</span> buf[]; <span class="comment">/*字符数组*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><ol><li>flags表示SDS的类型，一共有5种类型 <del>sdshdr5(已废弃)</del>、sdshdr8、sdshdr16、sdshdr32、sdshdr64, 区别：不同类型SDS结构中len和alloc这俩个元数据的数据类型不同（类型sdshdr8 表示 字符数组长度(包括最后一位0)不超过256字节(2^8)</li></ol><p>​      <strong>SDS设计不同的结构头（即不同类型），是为了能灵活保存不同大小的字符串，从而有效节省内存空间(<strong>因为保存不同大小的字符串时，结构头占用的内存空间也不一样，保存较小的字符串时，结构头也就占用较小的空间</strong>)</strong></p><ol start="2"><li><strong><strong>attribute</strong> ((packed))的作用</strong>: 告诉编译器，在编译sdshdr8结构时，不要使用字节对齐的方式，而是**采用紧凑的方式分配内存-按实际占用的字节数,**来实现紧凑型内存布局，达到节省内存的目的</li></ol><p>​    (字节对齐的方式: 这是因为在默认情况下，编译器会按照8字节对齐的方式，给变量分配内存。也就是说，即使一个变量的大小不到8个字节，编译器也会给它分配8个字节**)**</p></blockquote><h3 id="3、SDS的优势"><a href="#3、SDS的优势" class="headerlink" title="3、SDS的优势"></a>3、SDS的优势</h3><ul><li><p>操作效率高：<strong>获取长度无需遍历，O(1)复杂度</strong></p></li><li><p>二进制安全：因单独记录长度字段，所以可存储包含 \0 的数据</p></li><li><p>兼容 C 字符串函数，可直接使用字符串 API</p></li><li><p>采用紧凑的方式分配内存</p></li><li><p>内存预分配：SDS 扩容，会多申请一些内存（小于 1MB 翻倍扩容，大于 1MB 按 1MB 扩容）</p></li><li><p>避免频繁的内存分配：SDS 缩容，不释放多余的内存，下次使用可直接复用这些内存 (这种策略，是以多占一些内存的方式，换取「追加」操作的速度,内存预分配策略，详细逻辑可以看 sds.c的 sdsMakeRoomFor 函数)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> reids </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> redis </tag>
            
            <tag> SDS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda表达式(一)</title>
      <link href="/posts/33923/"/>
      <url>/posts/33923/</url>
      
        <content type="html"><![CDATA[<h2 id="1、什么是lambda表达式"><a href="#1、什么是lambda表达式" class="headerlink" title="1、什么是lambda表达式"></a>1、什么是lambda表达式</h2><p>Java8 是我们使用最广泛的稳定 Java 版本，lambda 就是其中最引人瞩目的新特性。lambda 是一种闭包，它允许把函数当做参数来使用，是面向函数式编程的思想，可以使代码看起来更加简洁。是不是听得一脸懵逼？我举个栗子你就明白了。</p><p>烂掉牙的例子，在没有 lambda 时候，我们是这样写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部类写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClassMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//匿名内部类写法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;内部类写法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有 lambda 之后，我们就用 lambda 写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambda 写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaMain</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//lambda 写法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;Runnable--&gt;lambda写法&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们应该知道，实现线程有两种方法，<strong>一是继承 Thread 类，二是实现 Runnable 接口。那这里采用的就是后者，后者是一个函数式接口。</strong></p><h2 id="2、函数式接口"><a href="#2、函数式接口" class="headerlink" title="2、函数式接口"></a>2、函数式接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object&#x27;s</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 Runnable 源码可以看到，它是一个<strong>函数式接口。</strong>这类接口的特点是：用 @FunctionalInterface 注解修饰（主要用于编译级错误检查，加上该注解，当你写的接口不符合函数式接口定义的时候，编译器会报错），有且只有一个抽象方法。在原生 JDk 中的这类接口就可以使用 lambda 表达式。</p><p>上面的概念提到，把函数当做参数来使用。上面的 lambda 例子中，Thread 类的参数就是一个 Runnable 接口，lambda 就是实现这个接口并把它当做参数使用。所以上面的 () -&gt; System.out.println(“lambda写法”) 就是一个整个 lambda 表达式的参数（注意与后面的方法参数区分开，后面会讲）。细品加粗这句话，可以总结出，<strong>lambda 表达式就是创建某个类的函数式接口的实例对象。</strong>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;lambda写法&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="3、为什么需要lambda表达式"><a href="#3、为什么需要lambda表达式" class="headerlink" title="3、为什么需要lambda表达式"></a>3、为什么需要lambda表达式</h2><p>明白了什么是 lambda 表达式，那为什么要使用它呢？注意到使用 lambda 创建线程的时候，我们并不关心<strong>接口名，方法名，参数名。我们只关注他的参数类型，参数个数，返回值。所以原因就是简化代码，提高可读性</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> lambda </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC(七)</title>
      <link href="/posts/5236/"/>
      <url>/posts/5236/</url>
      
        <content type="html"><![CDATA[<h2 id="1、锁"><a href="#1、锁" class="headerlink" title="1、锁"></a>1、锁</h2><h3 id="1-1、公平锁与非公平锁"><a href="#1-1、公平锁与非公平锁" class="headerlink" title="1.1、公平锁与非公平锁"></a>1.1、公平锁与非公平锁</h3><ul><li>公平fair锁：遵守FIFS，先来先服务，按照线程的申请顺序</li><li>非公平Nofair：多个线程获取锁的顺序不是严格按照申请的顺序，存在插队现象，在高并发的环境下，可能造成优先级反转或者饥饿现象，synchronized是一种非公平锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 默认非公平锁</span></span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平锁的先来先服务，保证公平，同样也是致命的问题。<br>比如买咖啡时，你买一杯，你前面那位买99杯，你的体验会特别的糟糕，现实中，你可以与前面的人商量让店员先给你做，然而公平锁是不允许这样交换的，就是先来先得。</p><h3 id="1-2、可重入锁（递归锁）"><a href="#1-2、可重入锁（递归锁）" class="headerlink" title="1.2、可重入锁（递归锁）"></a>1.2、可重入锁（递归锁）</h3><p>指的是同一线程外层函数获得锁之后，内层递归函数仍然能够获取该锁的代码<br>同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。<br>也就是说，线程可以进入任何一个它已经拥有的锁所同步着的代码块<br>同步方法1内部调用同步方法2，当线程获取同步方法1的锁，它也会获取方法2的锁。Synchronized和ReentrantLock是典型的可重入锁，可重入锁最大的作用是避免死锁</p><h3 id="1-3、独占锁（写锁）、共享锁（读锁）"><a href="#1-3、独占锁（写锁）、共享锁（读锁）" class="headerlink" title="1.3、独占锁（写锁）、共享锁（读锁）"></a>1.3、独占锁（写锁）、共享锁（读锁）</h3><p>独占锁：只能被一个线程占用，对ReentrantLock和Synchronized而言都是独占锁<br>共享锁：可以被多个线程所持有<br>对ReentrantReadWriteLock而言，读锁为共享，写锁为独占锁<br>读锁的共享锁可以保证并发读时非常高效的，读写、写写的过程是互斥</p><h3 id="1-4、自旋锁"><a href="#1-4、自旋锁" class="headerlink" title="1.4、自旋锁"></a>1.4、自旋锁</h3><p>是指尝试获取的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处就是减少线程上下文切换的消耗，缺点是循环会消耗CPU</p>]]></content>
      
      
      <categories>
          
          <category> juc </category>
          
          <category> 多线程 </category>
          
          <category> 锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC(六)</title>
      <link href="/posts/5237/"/>
      <url>/posts/5237/</url>
      
        <content type="html"><![CDATA[<h2 id="1、CPU密集型任务"><a href="#1、CPU密集型任务" class="headerlink" title="1、CPU密集型任务"></a>1、CPU密集型任务</h2><p>该任务需要大量的运算，没有阻塞，CPU一直全速运行。CPU密集任务只有在多核CPU上才可能通过多线程得到加速。CPU密集型任务配置尽可能少的线程数量，线程池大小的一般公式：<strong>CPU核数+1个线程</strong></p><p><strong>比如像加解密，压缩、计算等一系列需要大量耗费 CPU 资源的任务，大部分场景下都是纯 CPU 计算</strong></p><p>对于 CPU 密集型计算，多线程本质上是提升多核 CPU 的利用率，所以对于一个 8 核的 CPU，每个核一个线程，理论上创建 8 个线程就可以了。</p><p>如果设置过多的线程数，实际上并不会起到很好的效果。此时假设我们设置的线程数量是 CPU 核心数的 2 倍，因为计算任务非常重，会占用大量的 CPU 资源，所以这时 CPU 的每个核心工作基本都是满负荷的，</p><p>而我们又设置了过多的线程，每个线程都想去利用 CPU 资源来执行自己的任务，这就会造成不必要的上下文切换，此时线程数的增多并没有让性能提升，反而由于线程数量过多会导致性能下降。</p><p>因此，对于 CPU 密集型的计算场景，理论上线程的数量 &#x3D; CPU 核数就是最合适的，不过通常把线程的数量设置为CPU 核数 +1，会实现最优的利用率。</p><p>即使当密集型的线程由于偶尔的内存页失效或其他原因导致阻塞时，这个额外的线程也能确保 CPU 的时钟周期不会被浪费，从而保证 CPU 的利用率。</p><p>如下图就是在一个 8 核 CPU 的电脑上，通过修改线程数来测试对 CPU 密集型任务（素数计算）的性能影响。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gybyzsreurj30ze0o60ud.jpg"></p><p>可以看到线程数小于 8 时，性能是很差的，在线程数多于处理器核心数对性能的提升也很小，因此可以验证公式还是具有一定适用性的。</p><p>除此之外，我们最好还要同时考虑在同一台机器上还有哪些其他会占用过多 CPU 资源的程序在运行，然后对资源使用做整体的平衡。</p><h2 id="2、IO密集型任务"><a href="#2、IO密集型任务" class="headerlink" title="2、IO密集型任务"></a>2、IO密集型任务</h2><ul><li>由于IO密集型任务线程不是一直在执行的任务，则应配置尽可能多的线程，比如CPU核数*2</li><li>IO密集型，存在大量阻塞，在单线程上运行IO密集型任务会导致浪费大量的CPU运算能力，所以在IO密集型任务中使用多线程可以大大加速程序运行。参考公式：<strong>CPU核数&#x2F;(1-阻塞系数)，阻塞系数∈[0.8, 0.9]</strong></li></ul><p>对于 IO 密集型任务最大线程数一般会大于 CPU 核心数很多倍，因为 IO 读写速度相比于 CPU 的速度而言是比较慢的，如果我们设置过少的线程数，就可能导致 CPU 资源的浪费。而如果我们设置更多的线程数，那么当一部分线程正在等待 IO 的时候，它们此时并不需要 CPU 来计算，那么另外的线程便可以利用 CPU 去执行其他的任务，互不影响，这样的话在任务队列中等待的任务就会减少，可以更好地利用资源。</p><p>对于 IO 密集型计算场景，最佳的线程数是与程序中 CPU 计算和 IO 操作的耗时比相关的，《Java并发编程实战》的作者 Brain Goetz 推荐的计算方法如下：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gybz46tjhwj30yw0i4wfg.jpg"></p><p>还有一派的计算方式是《Java虚拟机并发编程》中提出的：</p><p>线程数 &#x3D; CPU 核心数 &#x2F; (1 - 阻塞系数)</p><p><strong>其中计算密集型阻塞系数为 0，IO 密集型阻塞系数接近 1，一般认为在 0.8 ~ 0.9 之间。比如 8 核 CPU，按照公式就是 2 &#x2F; ( 1 - 0.9 ) &#x3D; 20 个线程数</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gybz5grmknj30yy0iymyd.jpg"></p><p>上图是 IO 密集型任务的一个测试，是在双核处理器上开不同的线程数（从 1 到 40）来测试对程序性能的影响，可以看到线程池数量达到 20 之后，曲线逐渐水平，说明开再多的线程对程序的性能提升也毫无帮助。</p><p>太少的线程数会使得程序整体性能降低，而过多的线程也会消耗内存等其他资源，所以如果想要更准确的话，可以进行压测，监控 JVM 的线程情况以及 CPU 的负载情况，根据实际情况衡量应该创建的线程数，合理并充分利用资源。</p><p>同时，有很多线程池的应用，比如 Tomcat、Redis、Jdbc 等，每个应用设置的线程数也是不同的，比如 Tomcat 为流量入口，那么线程数的设置可能就要比其他应用要大。</p><h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><p>通过对线程数设置的探究，我们可以得知线程数的设置首先和 CPU 核心数有莫大关联，除此之外，我们需要根据任务类型的不同选择对应的策略，</p><p>线程的平均工作时间所占比例越高，就需要越少的线程；</p><p>线程的平均等待时间所占比例越高，就需要越多的线程；</p><p>针对不同的程序，进行对应的实际测试就可以得到最合适的选择。</p>]]></content>
      
      
      <categories>
          
          <category> juc </category>
          
          <category> 多线程 </category>
          
          <category> 线程池配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
            <tag> 线程池配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC(五)</title>
      <link href="/posts/46167/"/>
      <url>/posts/46167/</url>
      
        <content type="html"><![CDATA[<h2 id="1、线程池的工作原理"><a href="#1、线程池的工作原理" class="headerlink" title="1、线程池的工作原理"></a>1、线程池的工作原理</h2><p>我们在工作中或多或少都使用过线程池。但是为什么要使用线程池呢？从它的名称中我们就可以猜到，线程池是使用了一种池化技术（Pooling Technology）。和很多其他池化技术一样，都是为了更高效的利用资源，例如连接池，内存池等。</p><p>数据库连接是一种很昂贵的资源，创建和销毁都需要付出高昂的代价。为了避免频繁地创建数据库连接，所以产生了数据库连接池技术。优先在池子中创建一批数据库连接，当有需要访问数据库时，直接到池子中去获取一个可用的连接，使用完了之后再归还到连接池中去。</p><p>同样的，线程也是一种很宝贵的资源，并且也是一种有限的资源，创建和销毁线程也同样需要付出不菲的代价。我们所有的代码执行都是由一个一个的线程支撑起来的，如今的芯片架构也决定了我们必须编写多线程执行的程序，以获得最高的程序性能。那么怎样高效地管理多线程之间的分工与协作就成了一个关键问题，Doug Lea大神为我们设计并实现了一款线程池工具，通过该工具就可以实现多线程的能力，并实现任务的高效执行与调度。为了正确合理地使用线程池工具，我们有必要对线程池的原理进行了解。</p><p>了解线程池工作原理主要有三个方面：线程池状态、线程池的重要属性和线程池的工作流程。</p><h3 id="1-1、线程池的状态"><a href="#1-1、线程池的状态" class="headerlink" title="1.1、线程池的状态"></a>1.1、线程池的状态</h3><p>线程池是有状态的，这些状态标识这个线程池内部的一些运行情况。线程池的开启到关闭的过程就是线程池状态的一个流转过程。</p><p>线程池共有5种状态：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy9nuka1a6j31nu0iwgn2.jpg"></p><ul><li><strong>运行状态（RUNNING）</strong>：此状态下，线程池可以接受新的任务，也可以处理阻塞队列中的任务。执行shutdown()方法可进入待关闭（SHUTDOWN）状态，执行shutdownNow()方法可进入停止（STOP）状态</li><li><strong>待关闭状态（SHUTDOWN）</strong>：此状态下，线程池不再接受新的任务，继续处理阻塞队列中的任务。当阻塞队列中的任务为空，且工作线程数为0的时候，进入整理（TIDYING）状态。</li><li><strong>停止状态（STOP）</strong>：此状态下，线程池不接受新任务，也不处理阻塞队列中的任务，反而会尝试结束执行中的任务。当工作线程数为0时，进入整理（TIDYING)状态。</li><li><strong>整理状态（TIDYING）</strong>：此状态下，所有任务都已经执行完毕，且没有工作线程。执行terminated()方法进入终止（TERMINATED）状态。</li><li><strong>终止状态（TERMINATED）</strong>：此状态下，线程池完全终止，并完成了所有资源的释放。</li></ul><h3 id="1-3、线程池的重要属性"><a href="#1-3、线程池的重要属性" class="headerlink" title="1.3、线程池的重要属性"></a>1.3、<strong>线程池的重要属性</strong></h3><p>一个线程池的核心参数有很多，每个参数都有着特殊的作用，各个参数聚合再一起后将完成整个线程池的完整工作。其中的六个尤为重要：线程状态和工作线程的数量，核心线程数和最大线程数，创建线程的工厂，缓存任务的阻塞队列，非核心线程存活的时间和拒绝策略。</p><h3 id="1-4、线程状态和工作线程数量"><a href="#1-4、线程状态和工作线程数量" class="headerlink" title="1.4、线程状态和工作线程数量"></a>1.4、线程状态和工作线程数量</h3><p>首先线程池是有状态的，在不同的状态下，线程池的行为是不一样的。</p><p>然后线程池肯定是需要线程去执行具体的任务，所以在线程池中就封装了一个内部类Worker作为工作线程，每个Worker中都维持着一个Thread。</p><p>线程池的重点之一，就是控制线程资源合理高效的使用，所以必须控制工作线程的个数，所以需要保存当前线程池中工作线程的个数。</p><p>看到这里，你是否觉得需要用两个变量来保存线程池的状态和线程池中工作线程的个数呢？但是在ThreadPoolExecutor中只用了一个AtomicInteger型的变量就保存了这两个属性的值，那就是ctl。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy9o2tbhi2j31gi0iot9f.jpg"></p><p>ctl是一个原子操作类型（AtomicInteger）的变量。ctl的高3位用来表示线程池的状态（runState），低29位用来表示工作线程的个数（workerCnt）。为什么要用3位来表示线程池的状态呢，原因是因为线程池一共有5种状态，而2位只能表示出4种情况（2位是2^2，最多产生4种结果），至少需要3位才能表示得了全部的5种状态（3位是3^2，最多产生9种结果）</p><h4 id="1-4-1、核心线程数和最大线程数"><a href="#1-4-1、核心线程数和最大线程数" class="headerlink" title="1.4.1、核心线程数和最大线程数"></a>1.4.1、核心线程数和最大线程数</h4><p>现在有了标识工作线程的个数的变量了，那到底该有多少个线程才合适呢？线程多了会浪费线程资源，少了又不能发挥线程池的性能。</p><p>为了解决这个问题，线程池设计了两个变量来协作，分别是：</p><p>核心线程数（corePoolSize）：用来表示线程池中的核心线程的数量，也可以称为可闲置的线程数量。</p><p>最大线程数（maximumPoolSize）：用来表示线程池中最多能够创建的线程数量。</p><p>现在我们有一个疑惑，既然已经有了标识工作线程的个数的变量了，为什么还要有核心线程数和最大线程数呢？</p><p>其实你这样想就能够理解了，创建线程是有代价的，不能每次要执行一个任务时就创建一个线程，但是也不能在任务非常多的时候，只有少量的线程在执行，这样任务是来不及处理的，而是应该创建合适的足够多的线程来及时地处理任务。</p><p>随着任务数量的变化，当任务数量明显减少时，原本创建的多余的线程就没有必要再存活着了，因为这时使用少量的线程就能够处理得过来了，所以说真正工作的线程的数量，是随着任务的变化而变化的。</p><p>那核心线程数和最大线程数和工作线程个数的关系是什么呢？</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy9o5ssxqnj31gm0lwq4k.jpg"></p><p>工作线程的个数可能从0到最大线程数之间变化，当执行一段时间之后可能维持在核心线程数（corePoolSize），但也不是绝对的，取决于核心线程是否允许被超时回收。</p><h4 id="1-4-2、创建线程的工厂"><a href="#1-4-2、创建线程的工厂" class="headerlink" title="1.4.2、创建线程的工厂"></a>1.4.2、创建线程的工厂</h4><p>既然是线程池，那自然少不了线程。线程该如何来创建呢？这个任务就交给了线程工厂ThreadFactory来完成。</p><h4 id="1-4-3、缓存任务的阻塞队列"><a href="#1-4-3、缓存任务的阻塞队列" class="headerlink" title="1.4.3、缓存任务的阻塞队列"></a>1.4.3、缓存任务的阻塞队列</h4><p>上面我们说了核心线程数和最大线程数，并且也介绍了工作线程的个数是在0和最大线程数之间变化的。但是不可能一下子就创建了所有线程，把线程池装满，而是有一个过程：</p><p>当线程池接受到一个任务时，如果工作线程数没有达到corePoolSize，那么就会新建一个线程，并绑定该任务，只到工作线程的数量达到corePoolSize前都不会重用之前创建的线程。</p><p>当工作线程数达到corePoolSize了，这是又接收到新任务时，会将任务存放在一个阻塞队列（workQueue）中等待核心线程去执行。为什么不直接创建更多的线程来执行新任务呢？原因是核心线程中很可能已经有线程执行完自己的任务了，或者有其他线程马上就能处理完当前的任务，并且接下来就能投入到新的任务中去，所以阻塞队列是一种缓冲机制，给核心线程一个机会让他们充分发挥自己的能力。另外一个值得考虑的原因是，创建线程毕竟是代价昂贵的，不可能一有任务要执行就去创建一个新的线程。</p><p>所以我们需要为线程池配备一个阻塞队列，用来临时缓存任务，这些任务将等待工作线程来执行。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy9o8yjpv2j31by0a20tg.jpg"></p><h4 id="1-4-4、非核心线程存活时间"><a href="#1-4-4、非核心线程存活时间" class="headerlink" title="1.4.4、非核心线程存活时间"></a>1.4.4、非核心线程存活时间</h4><p>上面我们说了，当工作线程数达到corePoolSize时，线程池会将新接收到的任务放在阻塞队列中，而阻塞队列又分为两种情况：一种是有界的队列，一种是无界的队列。</p><p>如果是无界队列，那么当核心线程都在忙时，所有新提交的任务都会被存放在该无界队列中，这时最大线程数将变得没有意义，因为阻塞队列不会存在被装满的情况。</p><p>如果是有界队列，那么当阻塞队列中装满了等待执行的任务，这时再有新任务提交时，线程池就需要创建新的临时线程来处理，相当于增派人手来处理任务。</p><p>但是创建的临时线程是有存活时间的，不可能让它们一直都存活着，当阻塞队列中的任务被执行完毕，并且又没有那么多新任务被提交时，临时线程就需要被回收销毁，而在被回收销毁之前等待的这段时间，就是非核心线程的存活时间，也就是keepAliveTime属性。</p><p>那么什么是非核心线程呢？是不是先创建的线程就是核心线程，后创建的就是非核心线程呢？</p><p>其实核心线程跟创建的先后没有关系，而是跟工作线程的个数有关，如果当前工作线程的个数大于核心线程数，那么所有的线程都可能是非核心线程，都有被回收的可能。</p><p>一个线程执行完一个任务后，会去阻塞队列里面取新的任务，在取到任务之前，它就是一个闲置的线程。</p><p>取任务的方法有两种，一种是通过take()方法一直阻塞直到取出任务，另一种是通过poll(keepAliveTime, timeUnit)方法在一定时间内取出任务或者超时，如果超时这个线程就会被回收，请注意核心线程一般不会被回收。</p><p>那么怎么保证核心线程不会被回收呢？还是跟工作线程的个数有关，每一个线程在取任务的时候，线程池会比较当前的工作线程个数与核心线程数。</p><p>1.如果工作线程数小于当前的核心线程数，则使用第一种方法取任务，也就是没有超时回收，这时所有的工作线程都是核心线程，它们不会被回收。</p><p>2.如果工作线程数大于核心线程数，则使用第二种方法取任务，一旦超时就回收，所以并没有绝对的核心线程，只要这个线程没有在存活时间内取到任务去执行就会被回收。</p><p>所以每个线程如果想要保住自己核心线程的身份，必须充分努力，尽可能快得获取到任务去执行，这样才能避免被回收的命运。</p><p>核心线程一般不会被回收，但是也不是绝对的，如果我们设置了允许核心线程超时被回收的话，那么就没有核心线程这种说法了，所有的线程都会通过poll(keepAliveTime, timeUnit)来获取任务，一旦超时获取不到任务，就会被回收，一般很少会这样来使用，除非该线程池需要处理的任务非常少，并且频率也不高，不需要将核心线程一直维持着。</p><h4 id="1-4-5、拒绝策略"><a href="#1-4-5、拒绝策略" class="headerlink" title="1.4.5、拒绝策略"></a>1.4.5、拒绝策略</h4><p>虽然我们有了阻塞队列来对任务进行缓存，从一定程度上为线程池的执行提供了缓冲期，但是如果是有界的阻塞队列，那就存在队列满的情况，也存在工作线程的数据已经达到最大线程数的时候。如果这时候再有新的任务提交时，显然线程池已经心有余而力不足了，因为既没有空余的队列空间来存放该任务，也无法创建新的线程来执行该任务了，所以这时我们就需要有一种拒绝策略，即handler。</p><p>拒绝策略是一个RejectedExecutionHandler类型的变量，用户可以自行指定拒绝的策略，如果不指定的话，线程池将使用默认的拒绝策略：抛出异常。</p><p>在线程池中还为我们提供了很多其他可以选择的拒绝策略：</p><ol><li><p>直接丢弃该任务</p></li><li><p>使用调用者线程执行该任务</p></li><li><p>丢弃任务队列中的最老的一个任务，然后提交该任务</p></li></ol><h2 id="2、线程池的工作流程"><a href="#2、线程池的工作流程" class="headerlink" title="2、线程池的工作流程"></a>2、线程池的工作流程</h2><p>了解了线程池中所有的重要属性之后，现在我们需要来了解下线程池的工作流程了。</p><p>![image-20220111133835255](&#x2F;Users&#x2F;edwin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220111133835255.png)</p><p>上面是一张线程池工作的精简图，实际的过程要比这个复杂得多，但是这些应该能够完全覆盖到线程池的整个工作流程了。</p><p>整个过程可以拆分成以下几个部分：</p><h3 id="2-1、提交任务"><a href="#2-1、提交任务" class="headerlink" title="2.1、提交任务"></a>2.1、提交任务</h3><p>当向线程池提交一个新的任务时，线程池有三种处理情况，分别是：创建一个工作线程来执行该任务、将任务加入阻塞队列、拒绝该任务。</p><p>提交任务的过程也可以拆分成以下几个部分：</p><ol><li><p>当工作线程数小于核心线程数时，直接创建新的核心工作线程。 </p></li><li><p>当工作线程数大于核心线程数时，就需要尝试将任务添加到阻塞队列中去。</p></li><li><p>如果能够加入成功，说明队列还没满，那么就需要做以下的二次校验来保证添加进去的任务能够成功被执行。</p></li><li><p>验证当前线程池中的运行状态，如果是非RUNNING状态，则需要将任务从阻塞队列中移除，然后拒绝该任务。</p></li><li><p>验证当前线程池中的工作线程的个数，如果是0，则需要主动添加一个空工作线程来执行刚刚添加到阻塞队列中的任务。</p></li><li><p>如果加入失败，说明队列已经满了，这时就需要创建新的临时工作线程来执行任务。</p></li><li><p>如果创建成功，则直接执行该任务。</p></li><li><p>如果创建失败，说明工作线程数已经等于最大线程数了，只能拒绝该任务了。</p></li></ol><p>整个过程可以用下面这张图来表示：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy9ogo0hszj30u00vvacf.jpg"></p><h3 id="2-3、创建工作线程"><a href="#2-3、创建工作线程" class="headerlink" title="2.3、创建工作线程"></a>2.3、创建工作线程</h3><p>创建工作线程需要做一系列的判断，需要确保当前线程池可以创建新的线程之后，才能创建。</p><p>首先，当线程池的状态是SHUTDOWN或者STOP时，不能创建新的线程。</p><p>其次，当线程工厂创建线程失败时，也不能创建新的线程。</p><p>第三，拿当前工作线程的数量与核心线程数、最大线程数进行比较，如果前者大于后者的话，也不允许创建。</p><p>除此之外，线程池会尝试通过CAS来自增工作线程的个数，如果自增成功了，则会创建新的工作线程，即Worker对象。</p><p>然后加锁进行二次验证是否能够创建工作线程，如果最后创建成功，则会启动该工作线程。</p><h3 id="2-3、启动工作线程"><a href="#2-3、启动工作线程" class="headerlink" title="2.3、启动工作线程"></a>2.3、启动工作线程</h3><p>当工作线程创建成功后，也就是Worker对象已经创建好了，这时就需要启动该工作线程，让线程开始干活了，Worker对象中关联着一个Thread，所以要启动工作线程的话，只要通过worker.thread.start()来启动该线程即可。</p><p>启动完了之后，就会执行Worker对象的run方法，因为Worker实现了Runnable接口，所以本质上Worker也是一个线程。</p><p>通过线程start开启之后就会调用到Runnable的run方法，在Worker对象的run方法中，调用了runWorker(this)方法，也就是把当前对象传递给了runWorker()方法，让它来执行。</p><h3 id="2-4、获取任务并执行"><a href="#2-4、获取任务并执行" class="headerlink" title="2.4、获取任务并执行"></a>2.4、获取任务并执行</h3><p>在runWorker方法被调用之后，就是执行具体的任务了，首先需要拿到一个可以执行的任务，而Worker对象中默认绑定了一个任务，如果该任务不为空的话，那么就是直接执行。</p><p>执行完了之后，就会去阻塞队列中获取任务来执行。</p><p>获取任务的过程则需要考虑当前工作线程的个数：</p><ol><li><p>如果工作线程数大于核心线程数，那么就需要通过poll(keepAliveTime, timeUnit)来获取，因为这时需要对闲置线程进行超时回收。</p></li><li><p>如果工作线程数小于等于核心线程数，那么就可以通过take()来获取了。因为这时所有的线程都是核心线程，不需要进行回收，前提是没有设置allowCoreThreadTimeOut（允许核心线程超时回收）为true。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> juc </category>
          
          <category> 线程池工作原理 </category>
          
          <category> 线程池 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
            <tag> 线程池工作原理 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC(四)</title>
      <link href="/posts/45571/"/>
      <url>/posts/45571/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在学习面向对象OOP时，肯定听过一句话，java皆对象，要什么对象就new什么对象。<br>之后学习spring时，发现通过DI依赖注入后，便不再手动new对象了。<br>同理，在之前javase学习Thread时，手动new Thread，麻烦，另外gc也需要去不断收回，耗性能。<br>那么，我们能不能将所需要的线程提前创建好，并且可以反复利用呢？<br>线程池来了</p></blockquote><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>线程池的工作主要是控制运行线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等待，等待其他线程执行完毕。</p><p><strong>优势-主要特点是：线程复用；控制最大并发数；管理线程</strong></p><ul><li>降低资源消耗：通过复用已创建的线程降低线程的创建和销毁造成的消耗</li><li>提高响应速度：任务到达时，任务可以不需要等待线程创建，即可立即执行</li><li>提高线程的可管理性：线程是稀缺资源，如果无限制创建，会消耗系统资源，降低系统稳定性，使用线程池可以进行统一分配管理，调优和监控</li></ul><h2 id="2、线程池创建"><a href="#2、线程池创建" class="headerlink" title="2、线程池创建"></a>2、线程池创建</h2><table><thead><tr><th>线程池种类</th><th>说明</th></tr></thead><tbody><tr><td>Executors.newCachedThreadPool()</td><td>一池多线程带缓存，执行很多短期异步的小程序或者负载较轻的服务器</td></tr><tr><td>Executors.newFixedThreadPool()</td><td>一池固定线程，执行长期任务，性能好</td></tr><tr><td>Executors.newSingleThreadScheduledExecutor()</td><td>一池一线程，一个任务一个任务执行的场景</td></tr></tbody></table><p>Executors这个类中，定义Executor、ExecutorService、ScheduledExecutorService、ThreadFactory和Callable类的工厂和实用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                               <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                               <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、七个参数"><a href="#3、七个参数" class="headerlink" title="3、七个参数"></a>3、七个参数</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy8ik5qf23j31640u0gqh.jpg"></p><ul><li>maximumPoolSize：最大线程数 </li><li>keepAliveTime：多余的空闲线程存活时间。当前线程池数量超过corePoolSize时，当空闲时间达到KeepAliveTime时，多余空闲线程会被销毁直到只剩下corePoolSize个线程为止</li><li>unit：存活时间的单位 - workQueue：底层使用的阻塞队列，被提交但是还未执行的任务会保存在这里</li><li>threadFactory：线程工厂，表示生成线程池中工作线程的线程工厂，用于创建线程，一般默认即可 </li><li>handler：拒绝策略（有4种），当队列满了，并且工作线程大于等于线程池的最大线程数，应该如何处理多出来的线程</li></ul><h2 id="4、四种拒绝策略"><a href="#4、四种拒绝策略" class="headerlink" title="4、四种拒绝策略"></a>4、四种拒绝策略</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy8iqg3fctj31g60mqn1x.jpg"></p><ul><li>AbortPolicy（默认的拒绝策略）：直接抛出RejectedExecutionException异常阻止系统正常运行</li><li>CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不抛弃任务，也不会抛异常，而是将某些任务回退给调用者，从而降低新任务的流量</li><li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后将当前任务加入队列中尝试再次提交</li><li>DiscardPolicy：直接丢弃任务，不处理不抛异常。如果任务允许丢失，这是最好的一种</li></ul>]]></content>
      
      
      <categories>
          
          <category> juc </category>
          
          <category> 多线程 </category>
          
          <category> 线程池 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC(三)</title>
      <link href="/posts/9471/"/>
      <url>/posts/9471/</url>
      
        <content type="html"><![CDATA[<h2 id="1、阻塞队列"><a href="#1、阻塞队列" class="headerlink" title="1、阻塞队列"></a>1、阻塞队列</h2><table><thead><tr><th>BlockingQueue接口实现类</th><th>说明</th></tr></thead><tbody><tr><td>ArrayBlockingQueue</td><td>基于数组结构的有界阻塞队列，此队列按FIFO原则对元素进行排序</td></tr><tr><td>LinkedBlockingQueue</td><td>底层链表，有界<strong>（默认Integer.MAX_VALUE）</strong>吞吐量通常高于ArrayBlockingQueue</td></tr><tr><td>SynchronousQueue</td><td>一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态</td></tr><tr><td>PriorityBlockingQueue</td><td>支持优先级排序的<strong>无界</strong>阻塞队列</td></tr><tr><td>DelayQueue</td><td>使用优先级队列实现的延迟<strong>无界</strong>阻塞队列</td></tr><tr><td>LinkedTransferQueue</td><td>由链表实现的<strong>无界</strong>阻塞队列</td></tr><tr><td>LinkedBlockingDeque</td><td>由链表实现的<strong>双向</strong>阻塞队列</td></tr></tbody></table><h2 id="2、阻塞队列的好处"><a href="#2、阻塞队列的好处" class="headerlink" title="2、阻塞队列的好处"></a>2、阻塞队列的好处</h2><p>在多线程领域，所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足会被自动唤醒。<br>为什么需要BlockingQueue？<br>好处是我们不需要关心什么时候需要阻塞线程，是什么时候需要唤醒线程，因为这一切BlockingQueue都包办了。<br>在concurrent包发布之前，多线程下，我们每个程序员需要自己控制这些细节，尤其还需要兼顾效率和线程安全，而这会给程序带来不小的复杂度</p><h2 id="3、BlockingQueue的核心方法"><a href="#3、BlockingQueue的核心方法" class="headerlink" title="3、BlockingQueue的核心方法"></a>3、BlockingQueue的核心方法</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy2qhj8g9yj30yi07aab4.jpg"></p><table><thead><tr><th>方法类型</th><th>抛出异常</th><th>特殊值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr><td>插入</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e, time, unit)</td></tr><tr><td>移除</td><td>remove(e)</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td>检查</td><td>element()</td><td>peek()</td><td>-</td><td>-</td></tr></tbody></table><table><thead><tr><th>特性</th><th>满</th><th>空</th></tr></thead><tbody><tr><td>抛出异常</td><td>add会IllegalStateException: Queue full</td><td>remove会NoSuchElementException   <br />element会NoSuchElementException</td></tr><tr><td>特殊值</td><td>offer会false</td><td>poll、peek会null</td></tr><tr><td>一直阻塞</td><td>put死等</td><td>take死等</td></tr><tr><td>超时退出</td><td>offer有限等待</td><td>poll有限等待</td></tr></tbody></table><h2 id="4、源码"><a href="#4、源码" class="headerlink" title="4、源码"></a>4、源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@link</span> java.util.Queue&#125; that additionally supports operations</span></span><br><span class="line"><span class="comment"> * that wait for the queue to become non-empty when retrieving an</span></span><br><span class="line"><span class="comment"> * element, and wait for space to become available in the queue when</span></span><br><span class="line"><span class="comment"> * storing an element.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&#123;<span class="doctag">@code</span> BlockingQueue&#125; methods come in four forms, with different ways</span></span><br><span class="line"><span class="comment"> * of handling operations that cannot be satisfied immediately, but may be</span></span><br><span class="line"><span class="comment"> * satisfied at some point in the future:</span></span><br><span class="line"><span class="comment"> * one throws an exception, the second returns a special value (either</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> null&#125; or &#123;<span class="doctag">@code</span> false&#125;, depending on the operation), the third</span></span><br><span class="line"><span class="comment"> * blocks the current thread indefinitely until the operation can succeed,</span></span><br><span class="line"><span class="comment"> * and the fourth blocks for only a given maximum time limit before giving</span></span><br><span class="line"><span class="comment"> * up.  These methods are summarized in the following table:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;table BORDER CELLPADDING=3 CELLSPACING=1&gt;</span></span><br><span class="line"><span class="comment"> * &lt;caption&gt;Summary of BlockingQueue methods&lt;/caption&gt;</span></span><br><span class="line"><span class="comment"> *  &lt;tr&gt;</span></span><br><span class="line"><span class="comment"> *    &lt;td&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="comment"> *    &lt;td ALIGN=CENTER&gt;&lt;em&gt;Throws exception&lt;/em&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="comment"> *    &lt;td ALIGN=CENTER&gt;&lt;em&gt;Special value&lt;/em&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="comment"> *    &lt;td ALIGN=CENTER&gt;&lt;em&gt;Blocks&lt;/em&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="comment"> *    &lt;td ALIGN=CENTER&gt;&lt;em&gt;Times out&lt;/em&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="comment"> *  &lt;/tr&gt;</span></span><br><span class="line"><span class="comment"> *  &lt;tr&gt;</span></span><br><span class="line"><span class="comment"> *    &lt;td&gt;&lt;b&gt;Insert&lt;/b&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="comment"> *    &lt;td&gt;&#123;<span class="doctag">@link</span> #add add(e)&#125;&lt;/td&gt;</span></span><br><span class="line"><span class="comment"> *    &lt;td&gt;&#123;<span class="doctag">@link</span> #offer offer(e)&#125;&lt;/td&gt;</span></span><br><span class="line"><span class="comment"> *    &lt;td&gt;&#123;<span class="doctag">@link</span> #put put(e)&#125;&lt;/td&gt;</span></span><br><span class="line"><span class="comment"> *    &lt;td&gt;&#123;<span class="doctag">@link</span> #offer(Object, long, TimeUnit) offer(e, time, unit)&#125;&lt;/td&gt;</span></span><br><span class="line"><span class="comment"> *  &lt;/tr&gt;</span></span><br><span class="line"><span class="comment"> *  &lt;tr&gt;</span></span><br><span class="line"><span class="comment"> *    &lt;td&gt;&lt;b&gt;Remove&lt;/b&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="comment"> *    &lt;td&gt;&#123;<span class="doctag">@link</span> #remove remove()&#125;&lt;/td&gt;</span></span><br><span class="line"><span class="comment"> *    &lt;td&gt;&#123;<span class="doctag">@link</span> #poll poll()&#125;&lt;/td&gt;</span></span><br><span class="line"><span class="comment"> *    &lt;td&gt;&#123;<span class="doctag">@link</span> #take take()&#125;&lt;/td&gt;</span></span><br><span class="line"><span class="comment"> *    &lt;td&gt;&#123;<span class="doctag">@link</span> #poll(long, TimeUnit) poll(time, unit)&#125;&lt;/td&gt;</span></span><br><span class="line"><span class="comment"> *  &lt;/tr&gt;</span></span><br><span class="line"><span class="comment"> *  &lt;tr&gt;</span></span><br><span class="line"><span class="comment"> *    &lt;td&gt;&lt;b&gt;Examine&lt;/b&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="comment"> *    &lt;td&gt;&#123;<span class="doctag">@link</span> #element element()&#125;&lt;/td&gt;</span></span><br><span class="line"><span class="comment"> *    &lt;td&gt;&#123;<span class="doctag">@link</span> #peek peek()&#125;&lt;/td&gt;</span></span><br><span class="line"><span class="comment"> *    &lt;td&gt;&lt;em&gt;not applicable&lt;/em&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="comment"> *    &lt;td&gt;&lt;em&gt;not applicable&lt;/em&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="comment"> *  &lt;/tr&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/table&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A &#123;<span class="doctag">@code</span> BlockingQueue&#125; does not accept &#123;<span class="doctag">@code</span> null&#125; elements.</span></span><br><span class="line"><span class="comment"> * Implementations throw &#123;<span class="doctag">@code</span> NullPointerException&#125; on attempts</span></span><br><span class="line"><span class="comment"> * to &#123;<span class="doctag">@code</span> add&#125;, &#123;<span class="doctag">@code</span> put&#125; or &#123;<span class="doctag">@code</span> offer&#125; a &#123;<span class="doctag">@code</span> null&#125;.  A</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> null&#125; is used as a sentinel value to indicate failure of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> poll&#125; operations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A &#123;<span class="doctag">@code</span> BlockingQueue&#125; may be capacity bounded. At any given</span></span><br><span class="line"><span class="comment"> * time it may have a &#123;<span class="doctag">@code</span> remainingCapacity&#125; beyond which no</span></span><br><span class="line"><span class="comment"> * additional elements can be &#123;<span class="doctag">@code</span> put&#125; without blocking.</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@code</span> BlockingQueue&#125; without any intrinsic capacity constraints always</span></span><br><span class="line"><span class="comment"> * reports a remaining capacity of &#123;<span class="doctag">@code</span> Integer.MAX_VALUE&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&#123;<span class="doctag">@code</span> BlockingQueue&#125; implementations are designed to be used</span></span><br><span class="line"><span class="comment"> * primarily for producer-consumer queues, but additionally support</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@link</span> java.util.Collection&#125; interface.  So, for example, it is</span></span><br><span class="line"><span class="comment"> * possible to remove an arbitrary element from a queue using</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> remove(x)&#125;. However, such operations are in general</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;not&lt;/em&gt; performed very efficiently, and are intended for only</span></span><br><span class="line"><span class="comment"> * occasional use, such as when a queued message is cancelled.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&#123;<span class="doctag">@code</span> BlockingQueue&#125; implementations are thread-safe.  All</span></span><br><span class="line"><span class="comment"> * queuing methods achieve their effects atomically using internal</span></span><br><span class="line"><span class="comment"> * locks or other forms of concurrency control. However, the</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;bulk&lt;/em&gt; Collection operations &#123;<span class="doctag">@code</span> addAll&#125;,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> containsAll&#125;, &#123;<span class="doctag">@code</span> retainAll&#125; and &#123;<span class="doctag">@code</span> removeAll&#125; are</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;not&lt;/em&gt; necessarily performed atomically unless specified</span></span><br><span class="line"><span class="comment"> * otherwise in an implementation. So it is possible, for example, for</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> addAll(c)&#125; to fail (throwing an exception) after adding</span></span><br><span class="line"><span class="comment"> * only some of the elements in &#123;<span class="doctag">@code</span> c&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A &#123;<span class="doctag">@code</span> BlockingQueue&#125; does &lt;em&gt;not&lt;/em&gt; intrinsically support</span></span><br><span class="line"><span class="comment"> * any kind of &amp;quot;close&amp;quot; or &amp;quot;shutdown&amp;quot; operation to</span></span><br><span class="line"><span class="comment"> * indicate that no more items will be added.  The needs and usage of</span></span><br><span class="line"><span class="comment"> * such features tend to be implementation-dependent. For example, a</span></span><br><span class="line"><span class="comment"> * common tactic is for producers to insert special</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;end-of-stream&lt;/em&gt; or &lt;em&gt;poison&lt;/em&gt; objects, that are</span></span><br><span class="line"><span class="comment"> * interpreted accordingly when taken by consumers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Usage example, based on a typical producer-consumer scenario.</span></span><br><span class="line"><span class="comment"> * Note that a &#123;<span class="doctag">@code</span> BlockingQueue&#125; can safely be used with multiple</span></span><br><span class="line"><span class="comment"> * producers and multiple consumers.</span></span><br><span class="line"><span class="comment"> *  &lt;pre&gt; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * class Producer implements Runnable &#123;</span></span><br><span class="line"><span class="comment"> *   private final BlockingQueue queue;</span></span><br><span class="line"><span class="comment"> *   Producer(BlockingQueue q) &#123; queue = q; &#125;</span></span><br><span class="line"><span class="comment"> *   public void run() &#123;</span></span><br><span class="line"><span class="comment"> *     try &#123;</span></span><br><span class="line"><span class="comment"> *       while (true) &#123; queue.put(produce()); &#125;</span></span><br><span class="line"><span class="comment"> *     &#125; catch (InterruptedException ex) &#123; ... handle ...&#125;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> *   Object produce() &#123; ... &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * class Consumer implements Runnable &#123;</span></span><br><span class="line"><span class="comment"> *   private final BlockingQueue queue;</span></span><br><span class="line"><span class="comment"> *   Consumer(BlockingQueue q) &#123; queue = q; &#125;</span></span><br><span class="line"><span class="comment"> *   public void run() &#123;</span></span><br><span class="line"><span class="comment"> *     try &#123;</span></span><br><span class="line"><span class="comment"> *       while (true) &#123; consume(queue.take()); &#125;</span></span><br><span class="line"><span class="comment"> *     &#125; catch (InterruptedException ex) &#123; ... handle ...&#125;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> *   void consume(Object x) &#123; ... &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * class Setup &#123;</span></span><br><span class="line"><span class="comment"> *   void main() &#123;</span></span><br><span class="line"><span class="comment"> *     BlockingQueue q = new SomeQueueImplementation();</span></span><br><span class="line"><span class="comment"> *     Producer p = new Producer(q);</span></span><br><span class="line"><span class="comment"> *     Consumer c1 = new Consumer(q);</span></span><br><span class="line"><span class="comment"> *     Consumer c2 = new Consumer(q);</span></span><br><span class="line"><span class="comment"> *     new Thread(p).start();</span></span><br><span class="line"><span class="comment"> *     new Thread(c1).start();</span></span><br><span class="line"><span class="comment"> *     new Thread(c2).start();</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Memory consistency effects: As with other concurrent</span></span><br><span class="line"><span class="comment"> * collections, actions in a thread prior to placing an object into a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> BlockingQueue&#125;</span></span><br><span class="line"><span class="comment"> * &lt;a href=&quot;package-summary.html#MemoryVisibility&quot;&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * actions subsequent to the access or removal of that element from</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@code</span> BlockingQueue&#125; in another thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This interface is a member of the</span></span><br><span class="line"><span class="comment"> * &lt;a href=&quot;&#123;<span class="doctag">@docRoot</span>&#125;/../technotes/guides/collections/index.html&quot;&gt;</span></span><br><span class="line"><span class="comment"> * Java Collections Framework&lt;/a&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;E&gt; the type of elements held in this collection</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlockingQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Queue</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified element into this queue if it is possible to do</span></span><br><span class="line"><span class="comment">     * so immediately without violating capacity restrictions, returning</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> true&#125; upon success and throwing an</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> IllegalStateException&#125; if no space is currently available.</span></span><br><span class="line"><span class="comment">     * When using a capacity-restricted queue, it is generally preferable to</span></span><br><span class="line"><span class="comment">     * use &#123;<span class="doctag">@link</span> #offer(Object) offer&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalStateException if the element cannot be added at this</span></span><br><span class="line"><span class="comment">     *         time due to capacity restrictions</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the class of the specified element</span></span><br><span class="line"><span class="comment">     *         prevents it from being added to this queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if some property of the specified</span></span><br><span class="line"><span class="comment">     *         element prevents it from being added to this queue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified element into this queue if it is possible to do</span></span><br><span class="line"><span class="comment">     * so immediately without violating capacity restrictions, returning</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> true&#125; upon success and &#123;<span class="doctag">@code</span> false&#125; if no space is currently</span></span><br><span class="line"><span class="comment">     * available.  When using a capacity-restricted queue, this method is</span></span><br><span class="line"><span class="comment">     * generally preferable to &#123;<span class="doctag">@link</span> #add&#125;, which can fail to insert an</span></span><br><span class="line"><span class="comment">     * element only by throwing an exception.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the element was added to this queue, else</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the class of the specified element</span></span><br><span class="line"><span class="comment">     *         prevents it from being added to this queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if some property of the specified</span></span><br><span class="line"><span class="comment">     *         element prevents it from being added to this queue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified element into this queue, waiting if necessary</span></span><br><span class="line"><span class="comment">     * for space to become available.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the class of the specified element</span></span><br><span class="line"><span class="comment">     *         prevents it from being added to this queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if some property of the specified</span></span><br><span class="line"><span class="comment">     *         element prevents it from being added to this queue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified element into this queue, waiting up to the</span></span><br><span class="line"><span class="comment">     * specified wait time if necessary for space to become available.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout how long to wait before giving up, in units of</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@code</span> unit&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit a &#123;<span class="doctag">@code</span> TimeUnit&#125; determining how to interpret the</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@code</span> timeout&#125; parameter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful, or &#123;<span class="doctag">@code</span> false&#125; if</span></span><br><span class="line"><span class="comment">     *         the specified waiting time elapses before space is available</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the class of the specified element</span></span><br><span class="line"><span class="comment">     *         prevents it from being added to this queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if some property of the specified</span></span><br><span class="line"><span class="comment">     *         element prevents it from being added to this queue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e, <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Retrieves and removes the head of this queue, waiting if necessary</span></span><br><span class="line"><span class="comment">     * until an element becomes available.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the head of this queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Retrieves and removes the head of this queue, waiting up to the</span></span><br><span class="line"><span class="comment">     * specified wait time if necessary for an element to become available.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout how long to wait before giving up, in units of</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@code</span> unit&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit a &#123;<span class="doctag">@code</span> TimeUnit&#125; determining how to interpret the</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@code</span> timeout&#125; parameter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the head of this queue, or &#123;<span class="doctag">@code</span> null&#125; if the</span></span><br><span class="line"><span class="comment">     *         specified waiting time elapses before an element is available</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    E <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of additional elements that this queue can ideally</span></span><br><span class="line"><span class="comment">     * (in the absence of memory or resource constraints) accept without</span></span><br><span class="line"><span class="comment">     * blocking, or &#123;<span class="doctag">@code</span> Integer.MAX_VALUE&#125; if there is no intrinsic</span></span><br><span class="line"><span class="comment">     * limit.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that you &lt;em&gt;cannot&lt;/em&gt; always tell if an attempt to insert</span></span><br><span class="line"><span class="comment">     * an element will succeed by inspecting &#123;<span class="doctag">@code</span> remainingCapacity&#125;</span></span><br><span class="line"><span class="comment">     * because it may be the case that another thread is about to</span></span><br><span class="line"><span class="comment">     * insert or remove an element.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the remaining capacity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">remainingCapacity</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes a single instance of the specified element from this queue,</span></span><br><span class="line"><span class="comment">     * if it is present.  More formally, removes an element &#123;<span class="doctag">@code</span> e&#125; such</span></span><br><span class="line"><span class="comment">     * that &#123;<span class="doctag">@code</span> o.equals(e)&#125;, if this queue contains one or more such</span></span><br><span class="line"><span class="comment">     * elements.</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if this queue contained the specified element</span></span><br><span class="line"><span class="comment">     * (or equivalently, if this queue changed as a result of the call).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o element to be removed from this queue, if present</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this queue changed as a result of the call</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the class of the specified element</span></span><br><span class="line"><span class="comment">     *         is incompatible with this queue</span></span><br><span class="line"><span class="comment">     *         (&lt;a href=&quot;../Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment">     *         (&lt;a href=&quot;../Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if this queue contains the specified element.</span></span><br><span class="line"><span class="comment">     * More formally, returns &#123;<span class="doctag">@code</span> true&#125; if and only if this queue contains</span></span><br><span class="line"><span class="comment">     * at least one element &#123;<span class="doctag">@code</span> e&#125; such that &#123;<span class="doctag">@code</span> o.equals(e)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o object to be checked for containment in this queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this queue contains the specified element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the class of the specified element</span></span><br><span class="line"><span class="comment">     *         is incompatible with this queue</span></span><br><span class="line"><span class="comment">     *         (&lt;a href=&quot;../Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment">     *         (&lt;a href=&quot;../Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes all available elements from this queue and adds them</span></span><br><span class="line"><span class="comment">     * to the given collection.  This operation may be more</span></span><br><span class="line"><span class="comment">     * efficient than repeatedly polling this queue.  A failure</span></span><br><span class="line"><span class="comment">     * encountered while attempting to add elements to</span></span><br><span class="line"><span class="comment">     * collection &#123;<span class="doctag">@code</span> c&#125; may result in elements being in neither,</span></span><br><span class="line"><span class="comment">     * either or both collections when the associated exception is</span></span><br><span class="line"><span class="comment">     * thrown.  Attempts to drain a queue to itself result in</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> IllegalArgumentException&#125;. Further, the behavior of</span></span><br><span class="line"><span class="comment">     * this operation is undefined if the specified collection is</span></span><br><span class="line"><span class="comment">     * modified while the operation is in progress.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c the collection to transfer elements into</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of elements transferred</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if addition of elements</span></span><br><span class="line"><span class="comment">     *         is not supported by the specified collection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the class of an element of this queue</span></span><br><span class="line"><span class="comment">     *         prevents it from being added to the specified collection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the specified collection is this</span></span><br><span class="line"><span class="comment">     *         queue, or some property of an element of this queue prevents</span></span><br><span class="line"><span class="comment">     *         it from being added to the specified collection</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">drainTo</span><span class="params">(Collection&lt;? <span class="built_in">super</span> E&gt; c)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes at most the given number of available elements from</span></span><br><span class="line"><span class="comment">     * this queue and adds them to the given collection.  A failure</span></span><br><span class="line"><span class="comment">     * encountered while attempting to add elements to</span></span><br><span class="line"><span class="comment">     * collection &#123;<span class="doctag">@code</span> c&#125; may result in elements being in neither,</span></span><br><span class="line"><span class="comment">     * either or both collections when the associated exception is</span></span><br><span class="line"><span class="comment">     * thrown.  Attempts to drain a queue to itself result in</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> IllegalArgumentException&#125;. Further, the behavior of</span></span><br><span class="line"><span class="comment">     * this operation is undefined if the specified collection is</span></span><br><span class="line"><span class="comment">     * modified while the operation is in progress.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c the collection to transfer elements into</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxElements the maximum number of elements to transfer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of elements transferred</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if addition of elements</span></span><br><span class="line"><span class="comment">     *         is not supported by the specified collection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the class of an element of this queue</span></span><br><span class="line"><span class="comment">     *         prevents it from being added to the specified collection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the specified collection is this</span></span><br><span class="line"><span class="comment">     *         queue, or some property of an element of this queue prevents</span></span><br><span class="line"><span class="comment">     *         it from being added to the specified collection</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">drainTo</span><span class="params">(Collection&lt;? <span class="built_in">super</span> E&gt; c, <span class="type">int</span> maxElements)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> juc </category>
          
          <category> 多线程 </category>
          
          <category> 阻塞队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 阻塞队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC(二)</title>
      <link href="/posts/46173/"/>
      <url>/posts/46173/</url>
      
        <content type="html"><![CDATA[<h2 id="1、CAS"><a href="#1、CAS" class="headerlink" title="1、CAS"></a>1、CAS</h2><h3 id="1-1、概述"><a href="#1-1、概述" class="headerlink" title="1.1、概述"></a>1.1、概述</h3><blockquote><p>结合JMM线程的工作内存，主内存，副本之类的知识点。CAS主要对副本写回主内存进行了限定要求。<br>主存有一个变量为num，其值为5，称之为A，A指代主存num的值<br>Thread1从主内存拷贝副本到自己的工作内存，此时的副本称之为B，B指代副本num &#x3D; 5<br>Thread1将num修改为2019，此时称之为C，C指代副本num &#x3D; 2019<br>Thread1将修改过的num写回主内存时，做如下事情：<br>将B与A进行比较，如果相等，说明在我Thread1一顿猛操作的期间，没有第二个线程动过num，所以我Thread1可以大胆的将新num，也就是C，写回内存；</p><p>如果不相等，说明在我Thread1操作期间，有人先我一步动过了num，把它给改变了，那我之前的一顿操作都是在旧数据的基础上干的，其实就是白干了，所以无法写回内存。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 主内存的值</span></span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 修改成功返回true</span></span><br><span class="line">    atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">2019</span>);</span><br><span class="line">    <span class="comment">// 结果是2019</span></span><br><span class="line">    System.out.println(atomicInteger.get());</span><br><span class="line">    <span class="comment">// 修改失败返回false</span></span><br><span class="line">    atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">// 结果是2019</span></span><br><span class="line">    System.out.println(atomicInteger.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 源代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="comment">// this：当前对象</span></span><br><span class="line">    <span class="comment">// valueOffset：内存偏移量</span></span><br><span class="line">    <span class="comment">// expect：期望值，也就是上述的B</span></span><br><span class="line">    <span class="comment">// update：修改后的值，也就是上述的C</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CAS是一条CPU并发原语，功能是判断内存某个位置的值是否为预期值，是则更新，这个过程是原子的。<br>CAS并发原语体现在Java语言中就是sun.misc.Unsafe类中的各个方法。调用Unsafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语属于OS用语范畴，是由若干条指令组成，用语完成某个功能的一个 过程，并且原语的执行必须是连续不能被中断的，所以CAS不会造成数据不一致问题。</p><h2 id="2、Unsafe类"><a href="#2、Unsafe类" class="headerlink" title="2、Unsafe类"></a>2、Unsafe类</h2><p>CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。Unsafe类存在于sum.misc包中，其内部方法操作可以像C的指针一样直接操作内存。Java中CAS操作依赖于Unsafe类中的方法。</p><p>注意UnSafe类中的方法都是native修饰，也就是说Unsafe类中的方法都直接调用OS底层资源执行响应任务</p><h2 id="3、自旋锁"><a href="#3、自旋锁" class="headerlink" title="3、自旋锁"></a>3、自旋锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unsafe类中自旋锁的示例</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSetInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> newValue)</span> &#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 从内存偏移量offset的位置获取对象o的数据，相当于副本</span></span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">        <span class="comment">// 如果期望值与主存中的真实值不同会一直卡在这，自旋</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!weakCompareAndSetInt(o, offset, v, newValue));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">getIntVolatile</span><span class="params">(Object o, <span class="type">long</span> offset)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">weakCompareAndSetInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> expected, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> compareAndSetInt(o, offset, expected, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSetInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> expected, <span class="type">int</span> x)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>@HotSpotIntrinsicCandidate JDK9开始出现的注解，该注解表示此方法在HotSpot虚拟机中<strong>可能</strong>另有更加高效的实现</p></blockquote><h2 id="4、CAS的问题"><a href="#4、CAS的问题" class="headerlink" title="4、CAS的问题"></a>4、CAS的问题</h2><ul><li>一直卡while，CPU负担不小</li><li>ABA问题</li><li>CAS针对一个共享变量，多个不行，只能上锁</li></ul><h2 id="5、ABA问题"><a href="#5、ABA问题" class="headerlink" title="5、ABA问题"></a>5、ABA问题</h2><p>在前面概述中，读完后其实会有一个问题：期望值与主存中的值一致，就一定能够说明没有其他线程动过这个数据吗？<br>这是不能保证的，Thread1的期望值是A，它再写回主存之前，先比较主存的值是否是A。在比较之前，完全可以有另外的线程对该变量一通操作，最后重新改为A，Thread1就会误认为期间无其他线程动过数据。<br>这就是所谓的ABA问题</p><p><strong>如何解决ABA问题？</strong></p><p>时间戳原子引用，在比较期望值的同时，也会比较时间戳（版本号），类比数据库中的乐观锁。每次修改数据，数据的版本号都会发生变化，某一线程修改数据，不仅期望值要求一样，期望的版本号也要一致。这样就解决了ABA问题</p>]]></content>
      
      
      <categories>
          
          <category> juc </category>
          
          <category> 多线程 </category>
          
          <category> CAS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
            <tag> 多线程 </tag>
            
            <tag> CAS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC(一)</title>
      <link href="/posts/29945/"/>
      <url>/posts/29945/</url>
      
        <content type="html"><![CDATA[<blockquote><p>J（java）U（util）C（concurrent）其实就是指上图的三个包。</p></blockquote><h2 id="1、Volatitle"><a href="#1、Volatitle" class="headerlink" title="1、Volatitle"></a>1、Volatitle</h2><p>jvm提供的<strong>轻量级</strong>同步机制，它有三个特征</p><ul><li><p>保证可见性</p></li><li><p>禁止指令重排</p></li><li><p>不保证原子性</p><h3 id="JMM（Java-Memory-Model）"><a href="#JMM（Java-Memory-Model）" class="headerlink" title="JMM（Java Memory Model）"></a>JMM（Java Memory Model）</h3><p>java内存模型，一个非实际存在的抽象概念，是一个组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。</p><h6 id="JMM关于同步的规定"><a href="#JMM关于同步的规定" class="headerlink" title="JMM关于同步的规定"></a>JMM关于同步的规定</h6><ul><li><p>加锁前，线程从主存中读取最新的值到工作内存</p></li><li><p>解锁前，线程将自己的工作内存中的共享变量值写入主存内</p></li><li><p>加锁解锁，是对同一把锁</p><p><strong>JVM运行程序的实体是线程，每个线程进行创建是，JVM都会为其创建该线程独有的工作内存（栈空间）。当线程操作内存中的变量时，需要先将其拷贝到自己的空间，整一个副本，然后在自己的工作内存中对其操作，之后，将副本写回主内存</strong></p><p>从上述的描述，可以看到：在多线程并发的情况下，由于存在副本和副本写回这样的步骤，势必会出现类似脏读、幻读、不可重复读的问题。</p></li></ul><blockquote><p>比如：线程1、线程2将数据进行拷贝到自己的工作内存后，线程1进行数据修改并写回主内存，但是线程2还是使用原来的数据</p></blockquote><p>所以，只要有一个线程写回主存，那么应该通知其他线程，告诉它们：你们持有的此变量副本数据已经过期，赶紧从主内存读取，更新一下，别用旧的数据啦~~~<br>这种效果：即所谓的<code>可见性</code></p></li></ul><h2 id="2、指令重排"><a href="#2、指令重排" class="headerlink" title="2、指令重排"></a>2、指令重排</h2><p>​          计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令进行重排序</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxtdx51j2mj31do0hw750.jpg" /><p>单线程环境下，确保程序最终执行结果和代码顺序执行的结果一致<br>处理器在进行重排序时必须要考虑 指令之间的数据依赖性<br>多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性无法确定，结果无法预测.</p><p><strong>volatile实现禁止指令重排优化,从而避免多线程环境下程序出现乱序执行的现象</strong></p><h3 id="2-1-内存屏障-Memory-Barrier"><a href="#2-1-内存屏障-Memory-Barrier" class="headerlink" title="2.1 内存屏障(Memory Barrier)"></a>2.1 内存屏障(Memory Barrier)</h3><blockquote><p>内存屏障又称内存栅栏，是一个CPU指令，它的作用有两个</p><ul><li>保证特定操作的执行顺序</li><li>保证某些变量的内存可见性(利用该特性实现volatile的内存可见性)</li></ul></blockquote><p>由于编译器和处理器都能执行指令重排优化，如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。内存屏障另一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。</p>]]></content>
      
      
      <categories>
          
          <category> juc </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
            <tag> 多线程 </tag>
            
            <tag> volatitle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA基础回顾</title>
      <link href="/posts/15913/"/>
      <url>/posts/15913/</url>
      
        <content type="html"><![CDATA[<h5 id="1-8种基本数据类型"><a href="#1-8种基本数据类型" class="headerlink" title="1. 8种基本数据类型"></a>1. 8种基本数据类型</h5><p><img src="https://images.gitee.com/uploads/images/2019/1001/160806_dbece76c_5028606.jpeg" alt="java8中基本数据类型" title="java8中基本数据类型"></p><h5 id="2-面向对象的三大特性"><a href="#2-面向对象的三大特性" class="headerlink" title="2. 面向对象的三大特性"></a>2. 面向对象的三大特性</h5><ul><li>封装</li><li>继承</li><li>多态</li></ul><h5 id="3-、hashCode-、-equals"><a href="#3-、hashCode-、-equals" class="headerlink" title="3. &#x3D;&#x3D;、hashCode()、 equals()"></a>3. &#x3D;&#x3D;、hashCode()、 equals()</h5><ul><li><p>&#x3D;&#x3D;</p><ul><li>本质：是一个比较运算符</li><li>作用：比较俩个对象地址是否相等，基本数据类型比较的是值，引用数据类型比较的是内存地址</li></ul></li><li><p>hashCode() </p><ul><li>本质：返回一个int整数值(哈希码&#x2F;散列码)</li><li>作用：确定该对象在哈希表中的索引位置，也就是说hashCode()在散列表(Java集合中本质是散列表的类，如HashMap，Hashtable，HashSet。)中才有用，在其它情况下没用(例如，创建类的单个对象，或者创建类的对象数组等等)。</li><li>hashcode()定义在JDK的Object.java中，所以Java中的任何类都包含有该方法</li><li>使用：比较俩个引用类型对象是否相等时，需要重写该方法</li></ul></li><li><p>equals()</p><ul><li><p>作用：判断俩个引用类型对象的地址是否相等</p></li><li><p>使用：<br>  1). 类没有重写equals()方法。调用equals()比较该类的俩个对象时，等价与’&#x3D;&#x3D;’，比较的是俩个对象的地址值。<br>  2). 类重写equals()方法。比较的是俩个对象的内容(对象的属性值)是否相等。</p></li><li><p>源码<br><code>public boolean equals(Object obj) &#123;  return (this == obj);  &#125;</code></p></li></ul></li><li><p>一些特性</p><ul><li><strong>如果两个对象相等，则hashcode一定也是相同的</strong></li></ul></li><li><p><strong>两个对象有相同的hashcode值，它们也不一定是相等的</strong> </p></li><li><p><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></p></li></ul><h5 id="4-线程"><a href="#4-线程" class="headerlink" title="4. 线程"></a>4. 线程</h5><ul><li><p>定义：一个比进程更小的执行单位，一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p></li><li><p>基本状态</p><p><img src="https://images.gitee.com/uploads/images/2019/0929/170959_5599a2cf_5028606.png" alt="Java线程基本状态" title="java线程基本状态"></p><pre><code>                            图源《Java 并发编程艺术》4.1.4节</code></pre><p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。</p><p><img src="https://images.gitee.com/uploads/images/2019/0929/171406_4883b913_5028606.png" alt="Java线程运行状态" title="java线程运行状态"></p><pre><code>                            图源《Java 并发编程艺术》4.1.4节</code></pre><p>线程创建之后它将处于 NEW（新建） 状态，调用 start() 方法后开始运行，线程这时候处于 READY（可运行） 状态。可运行状态的线程获得了 cpu<br>时间片（timeslice）后就处于 RUNNING（运行） 状态。</p><p> :fa-camera:   <em>Java将操作系统中的运行和就绪两个状态合并称为运行状态。阻塞状态是线程阻塞在例如synchronized关键字修饰的方法或代码块(获取锁)时的状态，但是阻塞在java.concurrent包中Lock接口的线程状态却是等待状态，因为java.concurrent包中Lock接口对于阻塞的实现均使用了LockSupport类中的相关方法。</em></p></li></ul><h5 id="5-Java中的异常处理"><a href="#5-Java中的异常处理" class="headerlink" title="5.Java中的异常处理"></a>5.Java中的异常处理</h5><p><img src="https://images.gitee.com/uploads/images/2019/1001/161103_c8b3c9c9_5028606.png" alt="Java中的异常" title="在这里输入图片标题"></p><p>Java语言中，所有的异常都有一个共同的祖先java.lang包中的 Throwable类。Throwable： 有两个重要的子类：Exception（异常） 和 Error（错误） ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p><h6 id="5-1-Error（错误）"><a href="#5-1-Error（错误）" class="headerlink" title="5.1 Error（错误）"></a>5.1 Error（错误）</h6><p>Error（错误）是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</p><p>这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。</p><h6 id="5-2-Exception（异常）"><a href="#5-2-Exception（异常）" class="headerlink" title="5.2 Exception（异常）"></a>5.2 Exception（异常）</h6><p>Exception（异常）是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 异常由Java虚拟机抛出。NullPointerException（要访问的变量没有引用任何对象时，抛出该异常）、ArithmeticException（算术运算异常，一个整数除以0时，抛出该异常）和 ArrayIndexOutOfBoundsException （下标越界异常）。</p><p>:fa-camera:  异常和错误的区别：异常能被程序本身处理，错误是无法处理。</p><h6 id="5-3-Throwable类常用方法"><a href="#5-3-Throwable类常用方法" class="headerlink" title="5.3 Throwable类常用方法"></a>5.3 Throwable类常用方法</h6><ul><li>public string getMessage():返回异常发生时的详细信息</li><li>public string toString():返回异常发生时的简要描述</li><li>public string getLocalizedMessage():返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可以声称本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage（）返回的结果相同</li><li>public void printStackTrace():在控制台上打印Throwable对象封装的异常信息</li></ul><h5 id="6-IO"><a href="#6-IO" class="headerlink" title="6.IO"></a>6.IO</h5><h6 id="6-1-Java中IO流的分类"><a href="#6-1-Java中IO流的分类" class="headerlink" title="6.1 Java中IO流的分类"></a>6.1 Java中IO流的分类</h6><ul><li>按照流的流向分，可以分为输入流和输出流（输入和输出面向的主体程序）；</li><li>按照操作单元划分，可以划分为字节流和字符流；</li><li>按照流的角色划分为节点流和处理流。</li></ul><p>Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。</p><ul><li>InputStream&#x2F;Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li>OutputStream&#x2F;Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><p>按操作方式分类结构图：</p><p><img src="https://images.gitee.com/uploads/images/2019/1001/162446_95e3a29e_5028606.png" alt="输入图片说明" title="在这里输入图片标题"></p><p>按操作对象分类结构图：</p><p><img src="https://images.gitee.com/uploads/images/2019/1001/162536_27245fc5_5028606.png" alt="输入图片说明" title="在这里输入图片标题"></p><p> :fa-video-camera: BIO、NIO、AIO 区别</p><ul><li><p><strong>BIO (Blocking I&#x2F;O)</strong> : 同步阻塞I&#x2F;O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I&#x2F;O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I&#x2F;O 处理模型来应对更高的并发量。</p></li><li><p><strong>NIO (New I&#x2F;O)</strong> : NIO是一种同步非阻塞的I&#x2F;O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I&#x2F;O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I&#x2F;O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。</p></li><li><p><strong>AIO (Asynchronous I&#x2F;O)</strong> : AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 命令awk</title>
      <link href="/posts/64458/"/>
      <url>/posts/64458/</url>
      
        <content type="html"><![CDATA[<h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h4><pre><code>awk是一个报告生成器，它拥有强大的文本格式化的能力，这就是专业的说法。awk是由Alfred Aho 、Peter Weinberger 和 Brian Kernighan这三个人创造的，awk由这个三个人的姓氏的首个字母组成。awk早期是在unix上实现的，所以，我们现在在linux的所使用的awk其实是gawk，也就是GNU awk，简称为gawk，awk还有一个版本，New awk，简称为nawk，但是linux中最常用的还是gawk。awk其实是一门编程语言，它支持条件判断、数组、循环等功能。所以，我们也可以把awk理解成一个脚本语言解释器。</code></pre><p> grep 、sed、awk被称为linux中的”三剑客”。</p><p>  grep 更适合单纯的查找或匹配文本</p><p>  sed  更适合编辑匹配到的文本</p><p> awk  更适合格式化文本，对文本进行较复杂格式处理</p><h4 id="2-awk命令使用"><a href="#2-awk命令使用" class="headerlink" title="2 awk命令使用"></a>2 awk命令使用</h4><pre><code>    awk [选项参数] &#39;script&#39; var=value file(s)    或    awk [选项参数] -f scriptfile var=value file(s)</code></pre><h5 id="选项参数说明："><a href="#选项参数说明：" class="headerlink" title="选项参数说明："></a>选项参数说明：</h5><ul><li><p>-F fs or –field-separator fs</p><p> 指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。</p></li><li><p>-v var&#x3D;value or –asign var&#x3D;value</p><p>  赋值一个用户定义变量。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu桌面快捷图标</title>
      <link href="/posts/25850/"/>
      <url>/posts/25850/</url>
      
        <content type="html"><![CDATA[<h4 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch idea.desktop</span><br></pre></td></tr></table></figure><h4 id="写入下面内容"><a href="#写入下面内容" class="headerlink" title="写入下面内容"></a>写入下面内容</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line"></span><br><span class="line">Name=IntelliJ IDEA</span><br><span class="line"></span><br><span class="line">Comment=IntelliJ IDEA</span><br><span class="line"></span><br><span class="line">//idea 启动命令路径</span><br><span class="line">Exec=/home/edwin/work/work/soft/idea/bin/idea.sh </span><br><span class="line"></span><br><span class="line">//idea 图标路径</span><br><span class="line">Icon=/home/edwin/work/work/soft/idea/bin/idea.png</span><br><span class="line"></span><br><span class="line">Terminal=false</span><br><span class="line"></span><br><span class="line">Type=Application</span><br><span class="line"></span><br><span class="line">Categories=Developer;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 点滴 </category>
          
          <category> ubuntu </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu桌面快捷图标 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程和进程的区别-通俗版</title>
      <link href="/posts/3701/"/>
      <url>/posts/3701/</url>
      
        <content type="html"><![CDATA[<p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位</strong></p><p>做个简单的比喻进行来理解：</p><ol><li>进程&#x3D;火车，线程&#x3D;车厢,线程在进程下行进（单纯的车厢无法运行）</li><li>一个进程可以包含多个线程（一辆火车可以有多个车厢）</li><li>不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）</li><li>同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）</li><li>进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）</li><li>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）</li><li>进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）</li><li>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－”互斥锁”</li><li>进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程和进程的区别</title>
      <link href="/posts/48294/"/>
      <url>/posts/48294/</url>
      
        <content type="html"><![CDATA[<h1 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h1><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.</p><p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</p><h1 id="2-关系"><a href="#2-关系" class="headerlink" title="2.关系"></a>2.关系</h1><p>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</p><p>相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。</p><h1 id="3-区别"><a href="#3-区别" class="headerlink" title="3.区别"></a>3.区别</h1><p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p><ol><li>简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</li><li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li><li>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li><li>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li><li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</li></ol><h1 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="4.优缺点"></a>4.优缺点</h1><p>线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
